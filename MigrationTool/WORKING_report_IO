FILE: StringBufferInputStream.java
DIRECTORY: java/io
FILE: ObjectInputValidation.java
DIRECTORY: java/io
FILE: FilterOutputStream.java
DIRECTORY: java/io
FILE: Bits.java
DIRECTORY: java/io
FILE: EOFException.java
DIRECTORY: java/io
FILE: FileSystem.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Return the FileSystem object representing this platform's local
     * filesystem.
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * Return the FileSystem object representing this platform's local
     * filesystem.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: ObjectStreamException.java
DIRECTORY: java/io
FILE: PushbackInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(byte[] b, int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream into
     * an array of bytes.  This method first reads any pushed-back bytes; after
     * that, if fewer than <code>len</code> bytes have been read then it
     * reads from the underlying input stream.
     * {@description.close}
     * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until at least 1 byte of input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream into
     * an array of bytes.  This method first reads any pushed-back bytes; after
     * that, if fewer than <code>len</code> bytes have been read then it
     * reads from the underlying input stream.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
DESC BLOCK::: * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until at least 1 byte of input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEAREST SIGNATURE::: 
    public void unread(byte[] b) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Pushes back an array of bytes by copying it to the front of the
     * pushback buffer. After this method returns, the next byte to be read
     * will have the value <code>b[0]</code>, the byte after that will have the
     * value <code>b[1]</code>, and so forth.
     * {@description.close}
     * {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Pushes back an array of bytes by copying it to the front of the
     * pushback buffer. After this method returns, the next byte to be read
     * will have the value <code>b[0]</code>, the byte after that will have the
     * value <code>b[1]</code>, and so forth.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEW BLOCK:::* {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
ADDRESSED NEW::: [x]
---------
NEAREST SIGNATURE::: 
    public synchronized void mark(int readlimit) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Marks the current position in this input stream.
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.InputStream_MarkReset}
     * <p> The <code>mark</code> method of <code>PushbackInputStream</code>
     * does nothing.
     * {@new.open}
     * This method does not mark the current position; the first sentence is incorrect.
     * {@new.close}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.InputStream_MarkReset}
     * <p> The <code>mark</code> method of <code>PushbackInputStream</code>
     * does nothing.
     * {@new.open}
     * This method does not mark the current position; the first sentence is incorrect.
     * {@new.close}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Marks the current position in this input stream.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEW BLOCK:::* {@new.open}
     * This method does not mark the current position; the first sentence is incorrect.
     * {@new.close}
ADDRESSED NEW::: []
---------
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
     *
     * {@description.open}
     * <p> This method returns the most recently pushed-back byte, if there is
     * one, and otherwise calls the <code>read</code> method of its underlying
     * input stream and returns whatever value that method returns.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
DESC BLOCK::: * {@description.open}
     * <p> This method returns the most recently pushed-back byte, if there is
     * one, and otherwise calls the <code>read</code> method of its underlying
     * input stream and returns whatever value that method returns.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEAREST SIGNATURE::: 
    public void unread(byte[] b, int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Pushes back a portion of an array of bytes by copying it to the front
     * of the pushback buffer. After this method returns, the next byte to be
     * read will have the value <code>b[off]</code>, the byte after that will
     * have the value <code>b[off+1]</code>, and so forth.
     * {@description.close}
     * {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
ADDRESSED PROP::: []
---------
DESC BLOCK::: * {@description.open}
     * Pushes back a portion of an array of bytes by copying it to the front
     * of the pushback buffer. After this method returns, the next byte to be
     * read will have the value <code>b[off]</code>, the byte after that will
     * have the value <code>b[off+1]</code>, and so forth.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEW BLOCK:::* {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
ADDRESSED NEW::: []
---------
NEAREST SIGNATURE::: 
    public void unread(int b) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Pushes back a byte by copying it to the front of the pushback buffer.
     * After this method returns, the next byte to be read will have the value
     * <code>(byte)b</code>.
     * {@description.close}
     * {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.PushbackInputStream_UnreadAheadLimit}
     * {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
     * {@property.close}
ADDRESSED PROP::: []
---------
DESC BLOCK::: * {@description.open}
     * Pushes back a byte by copying it to the front of the pushback buffer.
     * After this method returns, the next byte to be read will have the value
     * <code>(byte)b</code>.
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEW BLOCK:::* {@new.open}
     * If the finite size of the internal pushback buffer is full, unread()
     * raises a runtime exception. The buffer size is specified when a
     * PushbackInputStream object is created.
     * {@new.close}
ADDRESSED NEW::: []
---------
NEAREST SIGNATURE::: 
    public PushbackInputStream(InputStream in) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a <code>PushbackInputStream</code>
     * and saves its  argument, the input stream
     * <code>in</code>, for later use. Initially,
     * there is no pushed-back byte  (the field
     * <code>pushBack</code> is initialized to
     * <code>-1</code>).
     * {@new.open}
     * This constructor creates the pushback buffer that holds only one byte.
     * {@new.close}
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a <code>PushbackInputStream</code>
     * and saves its  argument, the input stream
     * <code>in</code>, for later use. Initially,
     * there is no pushed-back byte  (the field
     * <code>pushBack</code> is initialized to
     * <code>-1</code>).
     * {@new.open}
     * This constructor creates the pushback buffer that holds only one byte.
     * {@new.close}
     * {@description.close}
ADDRESSED DESC::: [x]
---------
NEW BLOCK:::* {@new.open}
     * This constructor creates the pushback buffer that holds only one byte.
     * {@new.close}
ADDRESSED NEW::: []
---------
FILE: PipedReader.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public synchronized int read(char cbuf[], int off, int len)  throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> characters of data from this piped
     * stream into an array of characters. Less than <code>len</code> characters
     * will be read if the end of the data stream is reached or if
     * <code>len</code> exceeds the pipe's buffer size.
     * {@description.close}
     * {@description.open blocking}
     * This method
     * blocks until at least one character of input is available.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> characters of data from this piped
     * stream into an array of characters. Less than <code>len</code> characters
     * will be read if the end of the data stream is reached or if
     * <code>len</code> exceeds the pipe's buffer size.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method
     * blocks until at least one character of input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    synchronized void receivedLast() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Receives data into an array of characters.
     * {@description.close}
     * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * Receives data into an array of characters.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public synchronized int read()  throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next character of data from this piped stream.
     * If no character is available because the end of the stream
     * has been reached, the value <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data is available, the end of
     * the stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next character of data from this piped stream.
     * If no character is available because the end of the stream
     * has been reached, the value <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data is available, the end of
     * the stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    int out = 0;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * The index of the position in the circular buffer at which the
     * next character of data will be stored when received from the connected
     * piped writer. <code>in&lt;0</code> implies the buffer is empty,
     * <code>in==out</code> implies the buffer is full
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * The index of the position in the circular buffer at which the
     * next character of data will be stored when received from the connected
     * piped writer. <code>in&lt;0</code> implies the buffer is empty,
     * <code>in==out</code> implies the buffer is full
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
            notifyAll();
            try 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Receives a char of data.
     * {@description.close}
     * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * Receives a char of data.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: Flushable.java
DIRECTORY: java/io
FILE: BufferedInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public synchronized int available() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open blocking}
     * Returns an estimate of the number of bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream. The next invocation might be
     * the same thread or another thread.  A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     * {@description.close}
     * {@description.open}
     * <p>
     * This method returns the sum of the number of bytes remaining to be read in
     * the buffer (<code>count&nbsp;- pos</code>) and the result of calling the
     * {@link java.io.FilterInputStream#in in}.available().
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open blocking}
     * Returns an estimate of the number of bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream. The next invocation might be
     * the same thread or another thread.  A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * This method returns the sum of the number of bytes remaining to be read in
     * the buffer (<code>count&nbsp;- pos</code>) and the result of calling the
     * {@link java.io.FilterInputStream#in in}.available().
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: OutputStream.java
DIRECTORY: java/io
FILE: UnsupportedEncodingException.java
DIRECTORY: java/io
FILE: ObjectStreamConstants.java
DIRECTORY: java/io
FILE: InvalidObjectException.java
DIRECTORY: java/io
FILE: InputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int available() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns an estimate of the number of bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream. The next invocation
     * might be the same thread or another thread.
     * {@description.close}
     * {@description.open blocking}
     * A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     * {@description.close}
     *
     * {@property.open uncheckable}
     * <p> Note that while some implementations of {@code InputStream} will return
     * the total number of bytes in the stream, many will not.  It is
     * never correct to use the return value of this method to allocate
     * a buffer intended to hold all data in this stream.
     * {@new.open}
     * Since JavaMOP does not monitor local variable manipulation, this
     * property is not checkable.
     * {@new.close}
     * {@property.close}
     *
     * {@description.open}
     * <p> A subclass' implementation of this method may choose to throw an
     * {@link IOException} if this input stream has been closed by
     * invoking the {@link #close()} method.
     *
     * <p> The {@code available} method for class {@code InputStream} always
     * returns {@code 0}.
     * {@description.close}
     *
     * {@property.open static}
     * <p> This method should be overridden by subclasses.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open uncheckable}
     * <p> Note that while some implementations of {@code InputStream} will return
     * the total number of bytes in the stream, many will not.  It is
     * never correct to use the return value of this method to allocate
     * a buffer intended to hold all data in this stream.
     * {@new.open}
     * Since JavaMOP does not monitor local variable manipulation, this
     * property is not checkable.
     * {@new.close}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open static}
     * <p> This method should be overridden by subclasses.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Returns an estimate of the number of bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream. The next invocation
     * might be the same thread or another thread.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p> A subclass' implementation of this method may choose to throw an
     * {@link IOException} if this input stream has been closed by
     * invoking the {@link #close()} method.
     *
     * <p> The {@code available} method for class {@code InputStream} always
     * returns {@code 0}.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEW BLOCK:::* {@new.open}
     * Since JavaMOP does not monitor local variable manipulation, this
     * property is not checkable.
     * {@new.close}
ADDRESSED NEW::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from the input stream into
     * an array of bytes.  An attempt is made to read as many as
     * <code>len</code> bytes, but a smaller number may be read.
     * The number of bytes actually read is returned as an integer.
     * {@description.close}
     *
     * {@description.open blocking}
     * <p> This method blocks until input data is available, end of file is
     * detected, or an exception is thrown.
     *
     * <p> If <code>len</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at end of
     * file, the value <code>-1</code> is returned; otherwise, at least one
     * byte is read and stored into <code>b</code>.
     * {@description.close}
     *
     * {@property.open internal}
     * <p> The first byte read is stored into element <code>b[off]</code>, the
     * next one into <code>b[off+1]</code>, and so on. The number of bytes read
     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of
     * bytes actually read; these bytes will be stored in elements
     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through
     * <code>b[off+len-1]</code> unaffected.
     *
     * <p> In every case, elements <code>b[0]</code> through
     * <code>b[off]</code> and elements <code>b[off+len]</code> through
     * <code>b[b.length-1]</code> are unaffected.
     *
     * <p> The <code>read(b,</code> <code>off,</code> <code>len)</code> method
     * for class <code>InputStream</code> simply calls the method
     * <code>read()</code> repeatedly. If the first such call results in an
     * <code>IOException</code>, that exception is returned from the call to
     * the <code>read(b,</code> <code>off,</code> <code>len)</code> method.  If
     * any subsequent call to <code>read()</code> results in a
     * <code>IOException</code>, the exception is caught and treated as if it
     * were end of file; the bytes read up to that point are stored into
     * <code>b</code> and the number of bytes read before the exception
     * occurred is returned. The default implementation of this method blocks
     * until the requested amount of input data <code>len</code> has been read,
     * end of file is detected, or an exception is thrown. Subclasses are encouraged
     * to provide a more efficient implementation of this method.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open internal}
     * <p> The first byte read is stored into element <code>b[off]</code>, the
     * next one into <code>b[off+1]</code>, and so on. The number of bytes read
     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of
     * bytes actually read; these bytes will be stored in elements
     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through
     * <code>b[off+len-1]</code
...
eption is caught and treated as if it
     * were end of file; the bytes read up to that point are stored into
     * <code>b</code> and the number of bytes read before the exception
     * occurred is returned. The default implementation of this method blocks
     * until the requested amount of input data <code>len</code> has been read,
     * end of file is detected, or an exception is thrown. Subclasses are encouraged
     * to provide a more efficient implementation of this method.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from the input stream into
     * an array of bytes.  An attempt is made to read as many as
     * <code>len</code> bytes, but a smaller number may be read.
     * The number of bytes actually read is returned as an integer.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p> This method blocks until input data is available, end of file is
     * detected, or an exception is thrown.
     *
     * <p> If <code>len</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at end of
     * file, the value <code>-1</code> is returned; otherwise, at least one
     * byte is read and stored into <code>b</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads some number of bytes from the input stream and stores them into
     * the buffer array <code>b</code>. The number of bytes actually read is
     * returned as an integer.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data is
     * available, end of file is detected, or an exception is thrown.
     * {@description.close}
     *
     * {@description.open}
     * <p> If the length of <code>b</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at the
     * end of the file, the value <code>-1</code> is returned; otherwise, at
     * least one byte is read and stored into <code>b</code>.
     * {@description.close}
     *
     * {@property.open internal}
     * <p> The first byte read is stored into element <code>b[0]</code>, the
     * next one into <code>b[1]</code>, and so on. The number of bytes read is,
     * at most, equal to the length of <code>b</code>. Let <i>k</i> be the
     * number of bytes actually read; these bytes will be stored in elements
     * <code>b[0]</code> through <code>b[</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[</code><i>k</i><code>]</code> through
     * <code>b[b.length-1]</code> unaffected.
     * {@property.close}
     *
     * {@description.open}
     * <p> The <code>read(b)</code> method for class <code>InputStream</code>
     * has the same effect as: <pre><code> read(b, 0, b.length) </code></pre>
     * {@description.close}
     *
     
~
PROP BLOCK:::* {@property.open internal}
     * <p> The first byte read is stored into element <code>b[0]</code>, the
     * next one into <code>b[1]</code>, and so on. The number of bytes read is,
     * at most, equal to the length of <code>b</code>. Let <i>k</i> be the
     * number of bytes actually read; these bytes will be stored in elements
     * <code>b[0]</code> through <code>b[</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[</code><i>k</i><code>]</code> through
     * <code>b[b.length-1]</code> unaffected.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads some number of bytes from the input stream and stores them into
     * the buffer array <code>b</code>. The number of bytes actually read is
     * returned as an integer.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data is
     * available, end of file is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p> If the length of <code>b</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at the
     * end of the file, the value <code>-1</code> is returned; otherwise, at
     * least one byte is read and stored into <code>b</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p> The <code>read(b)</code> method for class <code>InputStream</code>
     * has the same effect as: <pre><code> read(b, 0, b.length) </code></pre>
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public abstract int read() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from the input stream. The value byte is
     * returned as an <code>int</code> in the range <code>0</code> to
     * <code>255</code>. If no byte is available because the end of the stream
     * has been reached, the value <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method
     * blocks until input data is available, the end of the stream is detected,
     * or an exception is thrown.
     * {@description.close}
     *
     * {@property.open enforced}
     * <p> A subclass must provide an implementation of this method.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open enforced}
     * <p> A subclass must provide an implementation of this method.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from the input stream. The value byte is
     * returned as an <code>int</code> in the range <code>0</code> to
     * <code>255</code>. If no byte is available because the end of the stream
     * has been reached, the value <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method
     * blocks until input data is available, the end of the stream is detected,
     * or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public long skip(long n) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Skips over and discards <code>n</code> bytes of data from this input
     * stream. The <code>skip</code> method may, for a variety of reasons, end
     * up skipping over some smaller number of bytes, possibly <code>0</code>.
     * This may result from any of a number of conditions; reaching end of file
     * before <code>n</code> bytes have been skipped is only one possibility.
     * The actual number of bytes skipped is returned.  If <code>n</code> is
     * negative, no bytes are skipped.
     *
     * <p> The <code>skip</code> method of this class creates a
     * byte array and then repeatedly reads into it until <code>n</code> bytes
     * have been read or the end of the stream has been reached. Subclasses are
     * encouraged to provide a more efficient implementation of this method.
     * For instance, the implementation may depend on the ability to seek.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Skips over and discards <code>n</code> bytes of data from this input
     * stream. The <code>skip</code> method may, for a variety of reasons, end
     * up skipping over some smaller number of bytes, possibly <code>0</code>.
     * This may result from any of a number of conditions; reaching end of file
     * before <code>n</code> bytes have been skipped is only one possibility.
     * The actual number of bytes skipped is returned.  If <code>n</code> is
     * negative, no bytes are skipped.
     *
     * <p> The <code>skip</code> method of this class creates a
     * byte array and then repeatedly reads into it until <code>n</code> bytes
     * have been read or the end of the stream has been reached. Subclasses are
     * encouraged to provide a more efficient implementation of this method.
     * For instance, the implementation may depend on the ability to seek.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: BufferedOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public synchronized void write(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this buffered output stream.
     *
     * <p> Ordinarily this method stores bytes from the given array into this
     * stream's buffer, flushing the buffer to the underlying output stream as
     * needed.  If the requested length is at least as large as this stream's
     * buffer, however, then this method will flush the buffer and write the
     * bytes directly to the underlying output stream.  Thus redundant
     * <code>BufferedOutputStream</code>s will not copy data unnecessarily.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this buffered output stream.
     *
     * <p> Ordinarily this method stores bytes from the given array into this
     * stream's buffer, flushing the buffer to the underlying output stream as
     * needed.  If the requested length is at least as large as this stream's
     * buffer, however, then this method will flush the buffer and write the
     * bytes directly to the underlying output stream.  Thus redundant
     * <code>BufferedOutputStream</code>s will not copy data unnecessarily.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FilterInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until some input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
     * {@description.open}
     * <p>
     * This method simply performs <code>in.read(b, off, len)</code>
     * and returns the result.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until some input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * This method simply performs <code>in.read(b, off, len)</code>
     * and returns the result.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>byte.length</code> bytes of data from this
     * input stream into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until some
     * input is available.
     * {@description.close}
     * {@description.open}
     * <p>
     * This method simply performs the call
     * <code>read(b, 0, b.length)</code> and returns
     * the  result. It is important that it does
     * <i>not</i> do <code>in.read(b)</code> instead;
     * certain subclasses of  <code>FilterInputStream</code>
     * depend on the implementation strategy actually
     * used.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>byte.length</code> bytes of data from this
     * input stream into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until some
     * input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * This method simply performs the call
     * <code>read(b, 0, b.length)</code> and returns
     * the  result. It is important that it does
     * <i>not</i> do <code>in.read(b)</code> instead;
     * certain subclasses of  <code>FilterInputStream</code>
     * depend on the implementation strategy actually
     * used.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int available() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@inheritDoc}
     * {@description.open}
     * <p>
     * This method simply performs <code>in.skip(n)</code>.
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * <p>
     * This method simply performs <code>in.skip(n)</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
     * {@description.open}
     * <p>
     * This method
     * simply performs <code>in.read()</code> and returns the result.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * This method
     * simply performs <code>in.read()</code> and returns the result.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: CharArrayWriter.java
DIRECTORY: java/io
FILE: Reader.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(char cbuf[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads characters into an array.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until some input
     * is available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads characters into an array.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until some input
     * is available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public long skip(long n) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Skips characters.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until some characters are
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Skips characters.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until some characters are
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a single character.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until a character is
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
     *
     * {@description.open}
     * <p> Subclasses that intend to support efficient single-character input
     * should override this method.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a single character.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until a character is
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p> Subclasses that intend to support efficient single-character input
     * should override this method.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    abstract public int read(char cbuf[], int off, int len) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads characters into a portion of an array.
     * {@description.close}
     * {@description.open blocking}
     * This method will block
     * until some input is available, an I/O error occurs, or the end of the
     * stream is reached.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads characters into a portion of an array.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block
     * until some input is available, an I/O error occurs, or the end of the
     * stream is reached.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: File.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public long length() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the length of the file denoted by this abstract pathname.
     * {@description.close}
     * {@property.open runtime formal:java.io.File_LengthOnDirectory}
     * The return value is unspecified if this pathname denotes a directory.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.File_LengthOnDirectory}
     * The return value is unspecified if this pathname denotes a directory.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Returns the length of the file denoted by this abstract pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setWritable(boolean writable) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * A convenience method to set the owner's write permission for this abstract
     * pathname.
     *
     * <p> An invocation of this method of the form <tt>file.setWritable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setWritable(arg, true) </pre>
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * A convenience method to set the owner's write permission for this abstract
     * pathname.
     *
     * <p> An invocation of this method of the form <tt>file.setWritable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setWritable(arg, true) </pre>
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public String[] list(FilenameFilter filter) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns an array of strings naming the files and directories in the
     * directory denoted by this abstract pathname that satisfy the specified
     * filter.  The behavior of this method is the same as that of the
     * {@link #list()} method, except that the strings in the returned array
     * must satisfy the filter.  If the given {@code filter} is {@code null}
     * then all names are accepted.  Otherwise, a name satisfies the filter if
     * and only if the value {@code true} results when the {@link
     * FilenameFilter#accept FilenameFilter.accept(File,&nbsp;String)} method
     * of the filter is invoked on this abstract pathname and the name of a
     * file or directory in the directory that it denotes.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns an array of strings naming the files and directories in the
     * directory denoted by this abstract pathname that satisfy the specified
     * filter.  The behavior of this method is the same as that of the
     * {@link #list()} method, except that the strings in the returned array
     * must satisfy the filter.  If the given {@code filter} is {@code null}
     * then all names are accepted.  Otherwise, a name satisfies the filter if
     * and only if the value {@code true} results when the {@link
     * FilenameFilter#accept FilenameFilter.accept(File,&nbsp;String)} method
     * of the filter is invoked on this abstract pathname and the name of a
     * file or directory in the directory that it denotes.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public static File createTempFile(String prefix, String suffix)
        throws IOException
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates an empty file in the default temporary-file directory, using
     * the given prefix and suffix to generate its name.  Invoking this method
     * is equivalent to invoking <code>{@link #createTempFile(java.lang.String,
     * java.lang.String, java.io.File)
     * createTempFile(prefix,&nbsp;suffix,&nbsp;null)}</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates an empty file in the default temporary-file directory, using
     * the given prefix and suffix to generate its name.  Invoking this method
     * is equivalent to invoking <code>{@link #createTempFile(java.lang.String,
     * java.lang.String, java.io.File)
     * createTempFile(prefix,&nbsp;suffix,&nbsp;null)}</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public URI toURI() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Constructs a <tt>file:</tt> URI that represents this abstract pathname.
     *
     * <p> The exact form of the URI is system-dependent.  If it can be
     * determined that the file denoted by this abstract pathname is a
     * directory, then the resulting URI will end with a slash.
     *
     * <p> For a given abstract pathname <i>f</i>, it is guaranteed that
     *
     * <blockquote><tt>
     * new {@link #File(java.net.URI) File}(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.{@link #getAbsoluteFile() getAbsoluteFile}())
     * </tt></blockquote>
     *
     * so long as the original abstract pathname, the URI, and the new abstract
     * pathname are all created in (possibly different invocations of) the same
     * Java virtual machine.  Due to the system-dependent nature of abstract
     * pathnames, however, this relationship typically does not hold when a
     * <tt>file:</tt> URI that is created in a virtual machine on one operating
     * system is converted into an abstract pathname in a virtual machine on a
     * different operating system.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Constructs a <tt>file:</tt> URI that represents this abstract pathname.
     *
     * <p> The exact form of the URI is system-dependent.  If it can be
     * determined that the file denoted by this abstract pathname is a
     * directory, then the resulting URI will end with a slash.
     *
     * <p> For a given abstract pathname <i>f</i>, it is guaranteed that
     *
     * <blockquote><tt>
     * new {@link #File(java.net.URI) File}(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&
...
as the original abstract pathname, the URI, and the new abstract
     * pathname are all created in (possibly different invocations of) the same
     * Java virtual machine.  Due to the system-dependent nature of abstract
     * pathnames, however, this relationship typically does not hold when a
     * <tt>file:</tt> URI that is created in a virtual machine on one operating
     * system is converted into an abstract pathname in a virtual machine on a
     * different operating system.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public File(URI uri) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a new <tt>File</tt> instance by converting the given
     * <tt>file:</tt> URI into an abstract pathname.
     *
     * <p> The exact form of a <tt>file:</tt> URI is system-dependent, hence
     * the transformation performed by this constructor is also
     * system-dependent.
     *
     * <p> For a given abstract pathname <i>f</i> it is guaranteed that
     *
     * <blockquote><tt>
     * new File(</tt><i>&nbsp;f</i><tt>.{@link #toURI() toURI}()).equals(</tt><i>&nbsp;f</i><tt>.{@link #getAbsoluteFile() getAbsoluteFile}())
     * </tt></blockquote>
     *
     * so long as the original abstract pathname, the URI, and the new abstract
     * pathname are all created in (possibly different invocations of) the same
     * Java virtual machine.  This relationship typically does not hold,
     * however, when a <tt>file:</tt> URI that is created in a virtual machine
     * on one operating system is converted into an abstract pathname in a
     * virtual machine on a different operating system.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a new <tt>File</tt> instance by converting the given
     * <tt>file:</tt> URI into an abstract pathname.
     *
     * <p> The exact form of a <tt>file:</tt> URI is system-dependent, hence
     * the transformation performed by this constructor is also
     * system-dependent.
     *
     * <p> For a given abstract pathname <i>f</i> it is guaranteed that
     *
     * <blockquote><tt>
     * new File(</tt><i>&nbsp;f</i><tt>.{@link #toURI() toURI}()).equals(</tt><i>&nbsp;f</i><
...
bsoluteFile}())
     * </tt></blockquote>
     *
     * so long as the original abstract pathname, the URI, and the new abstract
     * pathname are all created in (possibly different invocations of) the same
     * Java virtual machine.  This relationship typically does not hold,
     * however, when a <tt>file:</tt> URI that is created in a virtual machine
     * on one operating system is converted into an abstract pathname in a
     * virtual machine on a different operating system.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean renameTo(File dest) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Renames the file denoted by this abstract pathname.
     *
     * <p> Many aspects of the behavior of this method are inherently
     * platform-dependent: The rename operation might not be able to move a
     * file from one filesystem to another, it might not be atomic, and it
     * might not succeed if a file with the destination abstract pathname
     * already exists.  The return value should always be checked to make sure
     * that the rename operation was successful.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Renames the file denoted by this abstract pathname.
     *
     * <p> Many aspects of the behavior of this method are inherently
     * platform-dependent: The rename operation might not be able to move a
     * file from one filesystem to another, it might not be atomic, and it
     * might not succeed if a file with the destination abstract pathname
     * already exists.  The return value should always be checked to make sure
     * that the rename operation was successful.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setExecutable(boolean executable, boolean ownerOnly) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Sets the owner's or everybody's execute permission for this abstract
     * pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Sets the owner's or everybody's execute permission for this abstract
     * pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean canWrite() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Tests whether the application can modify the file denoted by this
     * abstract pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Tests whether the application can modify the file denoted by this
     * abstract pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public File[] listFiles() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns an array of abstract pathnames denoting the files in the
     * directory denoted by this abstract pathname.
     *
     * <p> If this abstract pathname does not denote a directory, then this
     * method returns {@code null}.  Otherwise an array of {@code File} objects
     * is returned, one for each file or directory in the directory.  Pathnames
     * denoting the directory itself and the directory's parent directory are
     * not included in the result.  Each resulting abstract pathname is
     * constructed from this abstract pathname using the {@link #File(File,
     * String) File(File,&nbsp;String)} constructor.  Therefore if this
     * pathname is absolute then each resulting pathname is absolute; if this
     * pathname is relative then each resulting pathname will be relative to
     * the same directory.
     *
     * <p> There is no guarantee that the name strings in the resulting array
     * will appear in any specific order; they are not, in particular,
     * guaranteed to appear in alphabetical order.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns an array of abstract pathnames denoting the files in the
     * directory denoted by this abstract pathname.
     *
     * <p> If this abstract pathname does not denote a directory, then this
     * method returns {@code null}.  Otherwise an array of {@code File} objects
     * is returned, one for each file or directory in the directory.  Pathnames
     * denoting the directory itself and the directory's parent directory are
     * not included in the result.  Each resulting a
...
e using the {@link #File(File,
     * String) File(File,&nbsp;String)} constructor.  Therefore if this
     * pathname is absolute then each resulting pathname is absolute; if this
     * pathname is relative then each resulting pathname will be relative to
     * the same directory.
     *
     * <p> There is no guarantee that the name strings in the resulting array
     * will appear in any specific order; they are not, in particular,
     * guaranteed to appear in alphabetical order.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean canRead() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Tests whether the application can read the file denoted by this
     * abstract pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Tests whether the application can read the file denoted by this
     * abstract pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean canExecute() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Tests whether the application can execute the file denoted by this
     * abstract pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Tests whether the application can execute the file denoted by this
     * abstract pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public File getCanonicalFile() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the canonical form of this abstract pathname.  Equivalent to
     * <code>new&nbsp;File(this.{@link #getCanonicalPath})</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns the canonical form of this abstract pathname.  Equivalent to
     * <code>new&nbsp;File(this.{@link #getCanonicalPath})</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setReadOnly() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Marks the file or directory named by this abstract pathname so that
     * only read operations are allowed.  After invoking this method the file
     * or directory is guaranteed not to change until it is either deleted or
     * marked to allow write access.  Whether or not a read-only file or
     * directory may be deleted depends upon the underlying system.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Marks the file or directory named by this abstract pathname so that
     * only read operations are allowed.  After invoking this method the file
     * or directory is guaranteed not to change until it is either deleted or
     * marked to allow write access.  Whether or not a read-only file or
     * directory may be deleted depends upon the underlying system.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setExecutable(boolean executable) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * A convenience method to set the owner's execute permission for this abstract
     * pathname.
     *
     * <p>An invocation of this method of the form <tt>file.setExcutable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setExecutable(arg, true) </pre>
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * A convenience method to set the owner's execute permission for this abstract
     * pathname.
     *
     * <p>An invocation of this method of the form <tt>file.setExcutable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setExecutable(arg, true) </pre>
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public String[] list() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns an array of strings naming the files and directories in the
     * directory denoted by this abstract pathname.
     *
     * <p> If this abstract pathname does not denote a directory, then this
     * method returns {@code null}.  Otherwise an array of strings is
     * returned, one for each file or directory in the directory.  Names
     * denoting the directory itself and the directory's parent directory are
     * not included in the result.  Each string is a file name rather than a
     * complete path.
     *
     * <p> There is no guarantee that the name strings in the resulting array
     * will appear in any specific order; they are not, in particular,
     * guaranteed to appear in alphabetical order.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns an array of strings naming the files and directories in the
     * directory denoted by this abstract pathname.
     *
     * <p> If this abstract pathname does not denote a directory, then this
     * method returns {@code null}.  Otherwise an array of strings is
     * returned, one for each file or directory in the directory.  Names
     * denoting the directory itself and the directory's parent directory are
     * not included in the result.  Each string is a file name rather than a
     * complete path.
     *
     * <p> There is no guarantee that the name strings in the resulting array
     * will appear in any specific order; they are not, in particular,
     * guaranteed to appear in alphabetical order.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean isFile() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Tests whether the file denoted by this abstract pathname is a normal
     * file.  A file is <em>normal</em> if it is not a directory and, in
     * addition, satisfies other system-dependent criteria.  Any non-directory
     * file created by a Java application is guaranteed to be a normal file.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Tests whether the file denoted by this abstract pathname is a normal
     * file.  A file is <em>normal</em> if it is not a directory and, in
     * addition, satisfies other system-dependent criteria.  Any non-directory
     * file created by a Java application is guaranteed to be a normal file.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public File[] listFiles(FilenameFilter filter) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns an array of abstract pathnames denoting the files and
     * directories in the directory denoted by this abstract pathname that
     * satisfy the specified filter.  The behavior of this method is the same
     * as that of the {@link #listFiles()} method, except that the pathnames in
     * the returned array must satisfy the filter.  If the given {@code filter}
     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname
     * satisfies the filter if and only if the value {@code true} results when
     * the {@link FilenameFilter#accept
     * FilenameFilter.accept(File,&nbsp;String)} method of the filter is
     * invoked on this abstract pathname and the name of a file or directory in
     * the directory that it denotes.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns an array of abstract pathnames denoting the files and
     * directories in the directory denoted by this abstract pathname that
     * satisfy the specified filter.  The behavior of this method is the same
     * as that of the {@link #listFiles()} method, except that the pathnames in
     * the returned array must satisfy the filter.  If the given {@code filter}
     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname
     * satisfies the filter if and only if the value {@code true} results when
     * the {@link FilenameFilter#accept
     * FilenameFilter.accept(File,&nbsp;String)} method of the filter is
     * invoked on this abstract pathname and the name of a file or directory in
     * the directory that it denotes.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean delete() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Deletes the file or directory denoted by this abstract pathname.  If
     * this pathname denotes a directory, then the directory must be empty in
     * order to be deleted.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Deletes the file or directory denoted by this abstract pathname.  If
     * this pathname denotes a directory, then the directory must be empty in
     * order to be deleted.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setReadable(boolean readable, boolean ownerOnly) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Sets the owner's or everybody's read permission for this abstract
     * pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Sets the owner's or everybody's read permission for this abstract
     * pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public File getAbsoluteFile() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the absolute form of this abstract pathname.  Equivalent to
     * <code>new&nbsp;File(this.{@link #getAbsolutePath})</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns the absolute form of this abstract pathname.  Equivalent to
     * <code>new&nbsp;File(this.{@link #getAbsolutePath})</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public long lastModified() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the time that the file denoted by this abstract pathname was
     * last modified.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns the time that the file denoted by this abstract pathname was
     * last modified.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setWritable(boolean writable, boolean ownerOnly) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Sets the owner's or everybody's write permission for this abstract
     * pathname.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Sets the owner's or everybody's write permission for this abstract
     * pathname.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

public class File
    implements Serializable, Comparable<File>

ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * An abstract representation of file and directory pathnames.
 *
 * <p> User interfaces and operating systems use system-dependent <em>pathname
 * strings</em> to name files and directories.  This class presents an
 * abstract, system-independent view of hierarchical pathnames.  An
 * <em>abstract pathname</em> has two components:
 *
 * <ol>
 * <li> An optional system-dependent <em>prefix</em> string,
 *      such as a disk-drive specifier, <code>"/"</code>&nbsp;for the UNIX root
 *      directory, or <code>"\\\\"</code>&nbsp;for a Microsoft Windows UNC pathname, and
 * <li> A sequence of zero or more string <em>names</em>.
 * </ol>
 *
 * The first name in an abstract pathname may be a directory name or, in the
 * case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
 * in an abstract pathname denotes a directory; the last name may denote
 * either a directory or a file.  The <em>empty</em> abstract pathname has no
 * prefix and an empty name sequence.
 *
 * <p> The conversion of a pathname string to or from an abstract pathname is
 * inherently system-dependent.  When an abstract pathname is converted into a
 * pathname string, each name is separated from the next by a single copy of
 * the default <em>separator character</em>.  The default name-separator
 * character is defined by the system property <code>file.separator</code>, and
 * is made available in the public static fields <code>{@link
 * #separator}</code> and <code>{@link #separatorChar}</code> of this class.
 * When a pathname string is converted into an abstract pathname, the names
 * within it may be separated by the default name-separator character or by any
 * other name-separator character that is supported by the underlying system.
 *
 * <p> A pathname, whether abstract or in string form, may be either
 * <em>absolute</em> or <em>relative</em>.  An absolute pathname is complete in
 * that no other information is required in order to locate the file that it
 * denotes.  A relative pathname, in contrast, must be interpreted in terms of
 * information taken from some other pathname.  By default the classes in the
 * <code>java.io</code> package always resolve relative pathnames against the
 * current user directory.  This directory is named by the system property
 * <code>user.dir</code>, and is typically the directory in which the Java
 * virtual machine was invoked.
 *
 * <p> The <em>parent</em> of an abstract pathname may be obtained by invoking
 * the {@link #getParent} method of this class and consists of the pathname's
 * prefix and each name in the pathname's name sequence except for the last.
 * Each directory's absolute pathname is an ancestor of any <tt>File</tt>
 * object with an absolute abstract pathname which begins with the directory's
 * absolute pathname.  For example, the directory denoted by the abstract
 * pathname <tt>"/usr"</tt> is an ancestor of the directory denoted by the
 * pathname <tt>"/usr/local/bin"</tt>.
 *
 * <p> The prefix concept is used to handle root directories on UNIX platforms,
 * and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
 * as follows:
 *
 * <ul>
 *
 * <li> For UNIX platforms, the prefix of an absolute pathname is always
 * <code>"/"</code>.  Relative pathnames have no prefix.  The abstract pathname
 * denoting the root directory has the prefix <code>"/"</code> and an empty
 * name sequence.
 *
 * <li> For Microsoft Windows platforms, the prefix of a pathname that contains a drive
 * specifier consists of the drive letter followed by <code>":"</code> and
 * possibly followed by <code>"\\"</code> if the pathname is absolute.  The
 * prefix of a UNC pathname is <code>"\\\\"</code>; the hostname and the share
 * name are the first two names in the name sequence.  A relative pathname that
 * does not specify a drive has no prefix.
 *
 * </ul>
 *
 * <p> Instances of this class may or may not denote an actual file-system
 * object such as a file or a directory.  If it does denote such an object
 * then that object resides in a <i>partition</i>.  A partition is an
 * operating system-specific portion of storage for a file system.  A single
 * storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
 * contain multiple partitions.  The object, if any, will reside on the
 * partition <a name="partName">named</a> by some ancestor of the absolute
 * form of this pathname.
 *
 * <p> A file system may implement restrictions to certain operations on the
 * actual file-system object, such as reading, writing, and executing.  These
 * restrictions are collectively known as <i>access permissions</i>.  The file
 * system may have multiple sets of access permissions on a single object.
 * For example, one set may apply to the object's <i>owner</i>, and another
 * may apply to all other users.  The access permissions on an object may
 * cause some methods in this class to fail.
 *
 * <p> Instances of the <code>File</code> class are immutable; that is, once
 * created, the abstract pathname represented by a <code>File</code> object
 * will never change.
 * {@description.close}
 *
 
~
DESC BLOCK::: * {@description.open}
 * An abstract representation of file and directory pathnames.
 *
 * <p> User interfaces and operating systems use system-dependent <em>pathname
 * strings</em> to name files and directories.  This class presents an
 * abstract, system-independent view of hierarchical pathnames.  An
 * <em>abstract pathname</em> has two components:
 *
 * <ol>
 * <li> An optional system-dependent <em>prefix</em> string,
 *      such as a disk-drive specifier, <code>"/"</code>&nbsp;for the UNIX root
 *      dir
...
y known as <i>access permissions</i>.  The file
 * system may have multiple sets of access permissions on a single object.
 * For example, one set may apply to the object's <i>owner</i>, and another
 * may apply to all other users.  The access permissions on an object may
 * cause some methods in this class to fail.
 *
 * <p> Instances of the <code>File</code> class are immutable; that is, once
 * created, the abstract pathname represented by a <code>File</code> object
 * will never change.
 * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean isDirectory() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Tests whether the file denoted by this abstract pathname is a
     * directory.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Tests whether the file denoted by this abstract pathname is a
     * directory.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean setReadable(boolean readable) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * A convenience method to set the owner's read permission for this abstract
     * pathname.
     *
     * <p>An invocation of this method of the form <tt>file.setReadable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setReadable(arg, true) </pre>
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * A convenience method to set the owner's read permission for this abstract
     * pathname.
     *
     * <p>An invocation of this method of the form <tt>file.setReadable(arg)</tt>
     * behaves in exactly the same way as the invocation
     *
     * <pre>
     *     file.setReadable(arg, true) </pre>
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: OutputStreamWriter.java
DIRECTORY: java/io
FILE: PrintStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void println(boolean x) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Terminates the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * <code>line.separator</code>, and is not necessarily a single newline
     * character (<code>'\n'</code>).
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * Terminates the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * <code>line.separator</code>, and is not necessarily a single newline
     * character (<code>'\n'</code>).
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FilterReader.java
DIRECTORY: java/io
FILE: FileNotFoundException.java
DIRECTORY: java/io
FILE: FilterWriter.java
DIRECTORY: java/io
FILE: SyncFailedException.java
DIRECTORY: java/io
FILE: StringReader.java
DIRECTORY: java/io
FILE: InvalidClassException.java
DIRECTORY: java/io
FILE: SerialCallbackContext.java
DIRECTORY: java/io
FILE: LineNumberInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
     * {@description.open}
     * <p>
     * The <code>read</code> method of
     * <code>LineNumberInputStream</code> calls the <code>read</code>
     * method of the underlying input stream. It checks for carriage
     * returns and newline characters in the input, and modifies the
     * current line number as appropriate. A carriage-return character or
     * a carriage return followed by a newline character are both
     * converted into a single newline character.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * The <code>read</code> method of
     * <code>LineNumberInputStream</code> calls the <code>read</code>
     * method of the underlying input stream. It checks for carriage
     * returns and newline characters in the input, and modifies the
     * current line number as appropriate. A carriage-return character or
     * a carriage return followed by a newline character are both
     * converted into a single newline character.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int available() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the number of bytes that can be read from this input
     * stream without blocking.
     * {@description.close}
     * {@property.open}
     * <p>
     * Note that if the underlying input stream is able to supply
     * <i>k</i> input characters without blocking, the
     * <code>LineNumberInputStream</code> can guarantee only to provide
     * <i>k</i>/2 characters without blocking, because the
     * <i>k</i> characters from the underlying input stream might
     * consist of <i>k</i>/2 pairs of <code>'&#92;r'</code> and
     * <code>'&#92;n'</code>, which are converted to just
     * <i>k</i>/2 <code>'&#92;n'</code> characters.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open}
     * <p>
     * Note that if the underlying input stream is able to supply
     * <i>k</i> input characters without blocking, the
     * <code>LineNumberInputStream</code> can guarantee only to provide
     * <i>k</i>/2 characters without blocking, because the
     * <i>k</i> characters from the underlying input stream might
     * consist of <i>k</i>/2 pairs of <code>'&#92;r'</code> and
     * <code>'&#92;n'</code>, which are converted to just
     * <i>k</i>/2 <code>'&#92;n'</code> characters.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Returns the number of bytes that can be read from this input
     * stream without blocking.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
@Deprecated
public
class LineNumberInputStream extends FilterInputStream 
ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * This class is an input stream filter that provides the added
 * functionality of keeping track of the current line number.
 * <p>
 * A line is a sequence of bytes ending with a carriage return
 * character (<code>'&#92;r'</code>), a newline character
 * (<code>'&#92;n'</code>), or a carriage return character followed
 * immediately by a linefeed character. In all three cases, the line
 * terminating character(s) are returned as a single newline character.
 * <p>
 * The line number begins at <code>0</code>, and is incremented by
 * <code>1</code> when a <code>read</code> returns a newline character.
 * {@description.close}
 *
 
~
DESC BLOCK::: * {@description.open}
 * This class is an input stream filter that provides the added
 * functionality of keeping track of the current line number.
 * <p>
 * A line is a sequence of bytes ending with a carriage return
 * character (<code>'&#92;r'</code>), a newline character
 * (<code>'&#92;n'</code>), or a carriage return character followed
 * immediately by a linefeed character. In all three cases, the line
 * terminating character(s) are returned as a single newline character.
 * <p>
 * The line number begins at <code>0</code>, and is incremented by
 * <code>1</code> when a <code>read</code> returns a newline character.
 * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until some input is available.
     * {@description.close}
     * {@description.open}
     * <p>
     * The <code>read</code> method of
     * <code>LineNumberInputStream</code> repeatedly calls the
     * <code>read</code> method of zero arguments to fill in the byte array.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until some input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * The <code>read</code> method of
     * <code>LineNumberInputStream</code> repeatedly calls the
     * <code>read</code> method of zero arguments to fill in the byte array.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: CharConversionException.java
DIRECTORY: java/io
FILE: Closeable.java
DIRECTORY: java/io
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Closes this stream and releases any system resources associated
     * with it.
     * {@description.close}
     * {@property.open runtime formal:java.io.Closeable_MultipleClose}
     * If the stream is already closed then invoking this
     * method has no effect.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.Closeable_MultipleClose}
     * If the stream is already closed then invoking this
     * method has no effect.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Closes this stream and releases any system resources associated
     * with it.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: Writer.java
DIRECTORY: java/io
FILE: PipedInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    synchronized void receive(byte b[], int off, int len)  throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Receives data into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Receives data into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public synchronized int read()  throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this piped input stream. The
     * value byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data is available, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this piped input stream. The
     * value byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data is available, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    protected synchronized void receive(int b) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Receives a byte of data.
     * {@description.close}
     * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Receives a byte of data.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public synchronized int read(byte b[], int off, int len)  throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this piped input
     * stream into an array of bytes. Less than <code>len</code> bytes
     * will be read if the end of the data stream is reached or if
     * <code>len</code> exceeds the pipe's buffer size.
     * {@description.close}
     * {@description.open blocking}
     * If <code>len </code> is zero, then no bytes are read and 0 is returned;
     * otherwise, the method blocks until at least 1 byte of input is
     * available, end of the stream has been detected, or an exception is
     * thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this piped input
     * stream into an array of bytes. Less than <code>len</code> bytes
     * will be read if the end of the data stream is reached or if
     * <code>len</code> exceeds the pipe's buffer size.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * If <code>len </code> is zero, then no bytes are read and 0 is returned;
     * otherwise, the method blocks until at least 1 byte of input is
     * available, end of the stream has been detected, or an exception is
     * thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    protected int in = -1;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * The index of the position in the circular buffer at which the
     * next byte of data will be stored when received from the connected
     * piped output stream. <code>in&lt;0</code> implies the buffer is empty,
     * <code>in==out</code> implies the buffer is full
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * The index of the position in the circular buffer at which the
     * next byte of data will be stored when received from the connected
     * piped output stream. <code>in&lt;0</code> implies the buffer is empty,
     * <code>in==out</code> implies the buffer is full
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: ObjectStreamField.java
DIRECTORY: java/io
FILE: DataInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public final int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from the contained
     * input stream into an array of bytes.  An attempt is made to read
     * as many as <code>len</code> bytes, but a smaller number may be read,
     * possibly zero. The number of bytes actually read is returned as an
     * integer.
     * {@description.close}
     *
     * {@description.open blocking}
     * <p> This method blocks until input data is available, end of file is
     * detected, or an exception is thrown.
     * {@description.close}
     *
     * {@description.open}
     * <p> If <code>len</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at end of
     * file, the value <code>-1</code> is returned; otherwise, at least one
     * byte is read and stored into <code>b</code>.
     *
     * <p> The first byte read is stored into element <code>b[off]</code>, the
     * next one into <code>b[off+1]</code>, and so on. The number of bytes read
     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of
     * bytes actually read; these bytes will be stored in elements
     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through
     * <code>b[off+len-1]</code> unaffected.
     *
     * <p> In every case, elements <code>b[0]</code> through
     * <code>b[off]</code> and elements <code>b[off+len]</code> through
     * <code>b[b.length-1]</code> are unaffected.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from the contained
     * input stream into an array of bytes.  An attempt is made to read
     * as many as <code>len</code> bytes, but a smaller number may be read,
     * possibly zero. The number of bytes actually read is returned as an
     * integer.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p> This method blocks until input data is available, end of file is
     * detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p> If <code>len</code> is zero, then no bytes are read and
     * <code>0</code> is returned; otherwise, there is an attempt to read at
     * least one byte. If no byte is available because the stream is at end of
     * file, the value <code>-1</code> is returned; otherwise, at least one
     * byte is read and stored into <code>b</code>.
     *
     * <p> The first byte read is stored into element <code>b[off]</code>, the
     * next one into <code>b[off+1]</code>, and so on. The n
...
ode>. Let <i>k</i> be the number of
     * bytes actually read; these bytes will be stored in elements
     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through
     * <code>b[off+len-1]</code> unaffected.
     *
     * <p> In every case, elements <code>b[0]</code> through
     * <code>b[off]</code> and elements <code>b[off+len]</code> through
     * <code>b[b.length-1]</code> are unaffected.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: DeleteOnExitHook.java
DIRECTORY: java/io
FILE: IOError.java
DIRECTORY: java/io
FILE: FilenameFilter.java
DIRECTORY: java/io
FILE: ObjectInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(byte[] buf, int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until some input
     * is available.
     * {@description.close}
     * {@description.open}
     * Consider using java.io.DataInputStream.readFully to read
     * exactly 'length' bytes.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until some input
     * is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * Consider using java.io.DataInputStream.readFully to read
     * exactly 'length' bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a byte of data.
     * {@description.close}
     * {@description.open blocking}
     * This method will block if no input is available.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a byte of data.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block if no input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public ObjectInputStream(InputStream in) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates an ObjectInputStream that reads from the specified InputStream.
     * A serialization stream header is read from the stream and verified.
     * {@description.close}
     * {@description.open blocking}
     * This constructor will block until the corresponding ObjectOutputStream
     * has written and flushed the header.
     * {@description.close}
     *
     * {@description.open}
     * <p>If a security manager is installed, this constructor will check for
     * the "enableSubclassImplementation" SerializablePermission when invoked
     * directly or indirectly by the constructor of a subclass which overrides
     * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
     * methods.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates an ObjectInputStream that reads from the specified InputStream.
     * A serialization stream header is read from the stream and verified.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This constructor will block until the corresponding ObjectOutputStream
     * has written and flushed the header.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>If a security manager is installed, this constructor will check for
     * the "enableSubclassImplementation" SerializablePermission when invoked
     * directly or indirectly by the constructor of a subclass which overrides
     * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
     * methods.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    protected Class<?> resolveProxyClass(String[] interfaces)
        throws IOException, ClassNotFoundException
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns a proxy class that implements the interfaces named in a proxy
     * class descriptor; subclasses may implement this method to read custom
     * data from the stream along with the descriptors for dynamic proxy
     * classes, allowing them to use an alternate loading mechanism for the
     * interfaces and the proxy class.
     *
     * <p>This method is called exactly once for each unique proxy class
     * descriptor in the stream.
     *
     * <p>The corresponding method in <code>ObjectOutputStream</code> is
     * <code>annotateProxyClass</code>.  For a given subclass of
     * <code>ObjectInputStream</code> that overrides this method, the
     * <code>annotateProxyClass</code> method in the corresponding subclass of
     * <code>ObjectOutputStream</code> must write any data or objects read by
     * this method.
     *
     * <p>The default implementation of this method in
     * <code>ObjectInputStream</code> returns the result of calling
     * <code>Proxy.getProxyClass</code> with the list of <code>Class</code>
     * objects for the interfaces that are named in the <code>interfaces</code>
     * parameter.  The <code>Class</code> object for each interface name
     * <code>i</code> is the value returned by calling
     * <pre>
     *     Class.forName(i, false, loader)
     * </pre>
     * where <code>loader</code> is that of the first non-<code>null</code>
     * class loader up the execution stack, or <code>null</code> if no
     * non-<code>null</code> class loaders are on the stack (the same class
     * loader choice used by the <code>resolveClass</code> method).  Unless any
     * of the resolved interfaces are non-public, this same value of
     * <code>loader</code> is also the class loader passed to
     * <code>Proxy.getProxyClass</code>; if non-public interfaces are present,
     * their class loader is passed instead (if more than one non-public
     * interface class loader is encountered, an
     * <code>IllegalAccessError</code> is thrown).
     * If <code>Proxy.getProxyClass</code> throws an
     * <code>IllegalArgumentException</code>, <code>resolveProxyClass</code>
     * will throw a <code>ClassNotFoundException</code> containing the
     * <code>IllegalArgumentException</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns a proxy class that implements the interfaces named in a proxy
     * class descriptor; subclasses may implement this method to read custom
     * data from the stream along with the descriptors for dynamic proxy
     * classes, allowing them to use an alternate loading mechanism for the
     * interfaces and the proxy class.
     *
     * <p>This method is called exactly once for each unique proxy class
     * descriptor in the stream.
     *
     * <p>The corresponding method 
...
<code>Proxy.getProxyClass</code>; if non-public interfaces are present,
     * their class loader is passed instead (if more than one non-public
     * interface class loader is encountered, an
     * <code>IllegalAccessError</code> is thrown).
     * If <code>Proxy.getProxyClass</code> throws an
     * <code>IllegalArgumentException</code>, <code>resolveProxyClass</code>
     * will throw a <code>ClassNotFoundException</code> containing the
     * <code>IllegalArgumentException</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void readFully(byte[] buf) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads bytes,
     * {@description.close}
     * {@description.open blocking}
     * blocking until all bytes are read.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads bytes,
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * blocking until all bytes are read.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: NotSerializableException.java
DIRECTORY: java/io
FILE: FileReader.java
DIRECTORY: java/io
FILE: BufferedWriter.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void write(char cbuf[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes a portion of an array of characters.
     *
     * <p> Ordinarily this method stores characters from the given array into
     * this stream's buffer, flushing the buffer to the underlying stream as
     * needed.  If the requested length is at least as large as the buffer,
     * however, then this method will flush the buffer and write the characters
     * directly to the underlying stream.  Thus redundant
     * <code>BufferedWriter</code>s will not copy data unnecessarily.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes a portion of an array of characters.
     *
     * <p> Ordinarily this method stores characters from the given array into
     * this stream's buffer, flushing the buffer to the underlying stream as
     * needed.  If the requested length is at least as large as the buffer,
     * however, then this method will flush the buffer and write the characters
     * directly to the underlying stream.  Thus redundant
     * <code>BufferedWriter</code>s will not copy data unnecessarily.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: DataOutput.java
DIRECTORY: java/io
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes two bytes of length information
     * to the output stream, followed
     * by the
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * representation
     * of  every character in the string <code>s</code>.
     * If <code>s</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * Each character in the string <code>s</code>
     * is converted to a group of one, two, or
     * three bytes, depending on the value of the
     * character.<p>
     * If a character <code>c</code>
     * is in the range <code>&#92;u0001</code> through
     * <code>&#92;u007f</code>, it is represented
     * by one byte:<p>
     * <pre>(byte)c </pre>  <p>
     * If a character <code>c</code> is <code>&#92;u0000</code>
     * or is in the range <code>&#92;u0080</code>
     * through <code>&#92;u07ff</code>, then it is
     * represented by two bytes, to be written
     * in the order shown:<p> <pre><code>
     * (byte)(0xc0 | (0x1f &amp; (c &gt;&gt; 6)))
     * (byte)(0x80 | (0x3f &amp; c))
     *  </code></pre>  <p> If a character
     * <code>c</code> is in the range <code>&#92;u0800</code>
     * through <code>uffff</code>, then it is
     * represented by three bytes, to be written
     * in the order shown:<p> <pre><code>
     * (byte)(0xe0 | (0x0f &amp; (c &gt;&gt; 12)))
     * (byte)(0x80 | (0x3f &amp; (c &gt;&gt;  6)))
     * (byte)(0x80 | (0x3f &amp; c))
     *  </code></pre>  <p> First,
     * the total number of bytes needed to represent
     * all the characters of <code>s</code> is
     * calculated. If this number is larger than
     * <code>65535</code>, then a <code>UTFDataFormatException</code>
     * is thrown. Otherwise, this length is written
     * to the output stream in exactly the manner
     * of the <code>writeShort</code> method;
     * after this, the one-, two-, or three-byte
     * representation of each character in the
     * string <code>s</code> is written.<p>  The
     * bytes written by this method may be read
     * by the <code>readUTF</code> method of interface
     * <code>DataInput</code> , which will then
     * return a <code>String</code> equal to <code>s</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes two bytes of length information
     * to the output stream, followed
     * by the
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * representation
     * of  every character in the string <code>s</code>.
     * If <code>s</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * Each character in the string <code>s</code>
     * is converted to a group of one, two, or
     * three bytes, depending on the value of the
     
...
own. Otherwise, this length is written
     * to the output stream in exactly the manner
     * of the <code>writeShort</code> method;
     * after this, the one-, two-, or three-byte
     * representation of each character in the
     * string <code>s</code> is written.<p>  The
     * bytes written by this method may be read
     * by the <code>readUTF</code> method of interface
     * <code>DataInput</code> , which will then
     * return a <code>String</code> equal to <code>s</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: BufferedReader.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void mark(int readAheadLimit) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Marks the present position in the stream.  Subsequent calls to reset()
     * will attempt to reposition the stream to this point.
     * {@description.close}
     * {@property.open runtime formal:java.io.Reader_MarkReset formal:java.io.Reader_UnmarkedReset formal:java.io.Reader_ReadAheadLimit}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.Reader_MarkReset formal:java.io.Reader_UnmarkedReset formal:java.io.Reader_ReadAheadLimit}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
NEAREST SIGNATURE::: 
    public void reset() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Resets the stream to the most recent mark.
     * {@description.close}
     * {@property.open runtime formal:java.io.Reader_MarkReset formal:java.io.Reader_UnmarkedReset formal:java.io.Reader_ReadAheadLimit}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.Reader_MarkReset formal:java.io.Reader_UnmarkedReset formal:java.io.Reader_ReadAheadLimit}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
NEAREST SIGNATURE::: 
    public int read(char cbuf[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads characters into a portion of an array.
     *
     * <p> This method implements the general contract of the corresponding
     * <code>{@link Reader#read(char[], int, int) read}</code> method of the
     * <code>{@link Reader}</code> class.  As an additional convenience, it
     * attempts to read as many characters as possible by repeatedly invoking
     * the <code>read</code> method of the underlying stream.  This iterated
     * <code>read</code> continues until one of the following conditions becomes
     * true: <ul>
     *
     *   <li> The specified number of characters have been read,
     *
     *   <li> The <code>read</code> method of the underlying stream returns
     *   <code>-1</code>, indicating end-of-file, or
     *
     *   <li> The <code>ready</code> method of the underlying stream
     *   returns <code>false</code>, indicating that further input requests
     *   would block.
     *
     * </ul> If the first <code>read</code> on the underlying stream returns
     * <code>-1</code> to indicate end-of-file then this method returns
     * <code>-1</code>.  Otherwise this method returns the number of characters
     * actually read.
     *
     * <p> Subclasses of this class are encouraged, but not required, to
     * attempt to read as many characters as possible in the same fashion.
     *
     * <p> Ordinarily this method takes characters from this stream's character
     * buffer, filling it from the underlying stream as necessary.  If,
     * however, the buffer is empty, the mark is not valid, and the requested
     * length is at least as large as the buffer, then this method will read
     * characters directly from the underlying stream into the given array.
     * Thus redundant <code>BufferedReader</code>s will not copy data
     * unnecessarily.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads characters into a portion of an array.
     *
     * <p> This method implements the general contract of the corresponding
     * <code>{@link Reader#read(char[], int, int) read}</code> method of the
     * <code>{@link Reader}</code> class.  As an additional convenience, it
     * attempts to read as many characters as possible by repeatedly invoking
     * the <code>read</code> method of the underlying stream.  This iterated
     * <code>read</code> continues until one of the fo
...
 fashion.
     *
     * <p> Ordinarily this method takes characters from this stream's character
     * buffer, filling it from the underlying stream as necessary.  If,
     * however, the buffer is empty, the mark is not valid, and the requested
     * length is at least as large as the buffer, then this method will read
     * characters directly from the underlying stream into the given array.
     * Thus redundant <code>BufferedReader</code>s will not copy data
     * unnecessarily.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: UTFDataFormatException.java
DIRECTORY: java/io
FILE: ObjectOutput.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void write(int b) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes a byte.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until the byte is actually
     * written.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Writes a byte.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until the byte is actually
     * written.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void write(byte b[]) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until the bytes
     * are actually written.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Writes an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until the bytes
     * are actually written.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FileOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    private native void open(String name) throws FileNotFoundException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Opens a file, with the specified name, for writing.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Opens a file, with the specified name, for writing.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public FileOutputStream(FileDescriptor fdObj) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates an output file stream to write to the specified file
     * descriptor, which represents an existing connection to an actual
     * file in the file system.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with the file descriptor <code>fdObj</code>
     * argument as its argument.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates an output file stream to write to the specified file
     * descriptor, which represents an existing connection to an actual
     * file in the file system.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with the file descriptor <code>fdObj</code>
     * argument as its argument.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    private native void openAppend(String name) throws FileNotFoundException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Opens a file, with the specified name, for appending.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Opens a file, with the specified name, for appending.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public FileOutputStream(String name, boolean append)
        throws FileNotFoundException
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates an output file stream to write to the file with the specified
     * <code>name</code>.  If the second argument is <code>true</code>, then
     * bytes will be written to the end of the file rather than the beginning.
     * A new <code>FileDescriptor</code> object is created to represent this
     * file connection.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with <code>name</code> as its argument.
     * <p>
     * If the file exists but is a directory rather than a regular file, does
     * not exist but cannot be created, or cannot be opened for any other
     * reason then a <code>FileNotFoundException</code> is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates an output file stream to write to the file with the specified
     * <code>name</code>.  If the second argument is <code>true</code>, then
     * bytes will be written to the end of the file rather than the beginning.
     * A new <code>FileDescriptor</code> object is created to represent this
     * file connection.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with <code>name</code> as its argument.
     * <p>
     * If the file exists but is a directory rather than a regular file, does
     * not exist but cannot be created, or cannot be opened for any other
     * reason then a <code>FileNotFoundException</code> is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public FileOutputStream(String name) throws FileNotFoundException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates an output file stream to write to the file with the
     * specified name. A new <code>FileDescriptor</code> object is
     * created to represent this file connection.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with <code>name</code> as its argument.
     * <p>
     * If the file exists but is a directory rather than a regular file, does
     * not exist but cannot be created, or cannot be opened for any other
     * reason then a <code>FileNotFoundException</code> is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates an output file stream to write to the file with the
     * specified name. A new <code>FileDescriptor</code> object is
     * created to represent this file connection.
     * <p>
     * First, if there is a security manager, its <code>checkWrite</code>
     * method is called with <code>name</code> as its argument.
     * <p>
     * If the file exists but is a directory rather than a regular file, does
     * not exist but cannot be created, or cannot be opened for any other
     * reason then a <code>FileNotFoundException</code> is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public FileOutputStream(String name) throws FileNotFoundException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * The system dependent file descriptor. The value is
     * 1 more than actual file descriptor. This means that
     * the default value 0 indicates that the file is not open.
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * The system dependent file descriptor. The value is
     * 1 more than actual file descriptor. This means that
     * the default value 0 indicates that the file is not open.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: PipedOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void write(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this piped output stream.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until all the bytes are written to the output
     * stream.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this piped output stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until all the bytes are written to the output
     * stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: PipedWriter.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void write(char cbuf[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes <code>len</code> characters from the specified character array
     * starting at offset <code>off</code> to this piped output stream.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until all the characters are written to the output
     * stream.
     * {@description.close}
     * {@description.open}
     * If a thread was reading data characters from the connected piped input
     * stream, but the thread is no longer alive, then an
     * <code>IOException</code> is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes <code>len</code> characters from the specified character array
     * starting at offset <code>off</code> to this piped output stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until all the characters are written to the output
     * stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * If a thread was reading data characters from the connected piped input
     * stream, but the thread is no longer alive, then an
     * <code>IOException</code> is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: IOException.java
DIRECTORY: java/io
FILE: StreamTokenizer.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void wordChars(int low, int hi) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are word constituents. A word token consists of a word constituent
     * followed by zero or more word constituents or number constituents.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are word constituents. A word token consists of a word constituent
     * followed by zero or more word constituents or number constituents.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void ordinaryChars(int low, int hi) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are "ordinary" in this tokenizer. See the
     * <code>ordinaryChar</code> method for more information on a
     * character being ordinary.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are "ordinary" in this tokenizer. See the
     * <code>ordinaryChar</code> method for more information on a
     * character being ordinary.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void eolIsSignificant(boolean flag) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Determines whether or not ends of line are treated as tokens.
     * If the flag argument is true, this tokenizer treats end of lines
     * as tokens; the <code>nextToken</code> method returns
     * <code>TT_EOL</code> and also sets the <code>ttype</code> field to
     * this value when an end of line is read.
     * <p>
     * A line is a sequence of characters ending with either a
     * carriage-return character (<code>'&#92;r'</code>) or a newline
     * character (<code>'&#92;n'</code>). In addition, a carriage-return
     * character followed immediately by a newline character is treated
     * as a single end-of-line token.
     * <p>
     * If the <code>flag</code> is false, end-of-line characters are
     * treated as white space and serve only to separate tokens.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Determines whether or not ends of line are treated as tokens.
     * If the flag argument is true, this tokenizer treats end of lines
     * as tokens; the <code>nextToken</code> method returns
     * <code>TT_EOL</code> and also sets the <code>ttype</code> field to
     * this value when an end of line is read.
     * <p>
     * A line is a sequence of characters ending with either a
     * carriage-return character (<code>'&#92;r'</code>) or a newline
     * character (<code>'&#92;n'</code>). In addition, a carriage-return
     * character followed immediately by a newline character is treated
     * as a single end-of-line token.
     * <p>
     * If the <code>flag</code> is false, end-of-line characters are
     * treated as white space and serve only to separate tokens.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void whitespaceChars(int low, int hi) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are white space characters. White space characters serve only to
     * separate tokens in the input stream.
     *
     * <p>Any other attribute settings for the characters in the specified
     * range are cleared.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Specifies that all characters <i>c</i> in the range
     * <code>low&nbsp;&lt;=&nbsp;<i>c</i>&nbsp;&lt;=&nbsp;high</code>
     * are white space characters. White space characters serve only to
     * separate tokens in the input stream.
     *
     * <p>Any other attribute settings for the characters in the specified
     * range are cleared.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void quoteChar(int ch) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Specifies that matching pairs of this character delimit string
     * constants in this tokenizer.
     * <p>
     * When the <code>nextToken</code> method encounters a string
     * constant, the <code>ttype</code> field is set to the string
     * delimiter and the <code>sval</code> field is set to the body of
     * the string.
     * <p>
     * If a string quote character is encountered, then a string is
     * recognized, consisting of all characters after (but not including)
     * the string quote character, up to (but not including) the next
     * occurrence of that same string quote character, or a line
     * terminator, or end of file. The usual escape sequences such as
     * <code>"&#92;n"</code> and <code>"&#92;t"</code> are recognized and
     * converted to single characters as the string is parsed.
     *
     * <p>Any other attribute settings for the specified character are cleared.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Specifies that matching pairs of this character delimit string
     * constants in this tokenizer.
     * <p>
     * When the <code>nextToken</code> method encounters a string
     * constant, the <code>ttype</code> field is set to the string
     * delimiter and the <code>sval</code> field is set to the body of
     * the string.
     * <p>
     * If a string quote character is encountered, then a string is
     * recognized, consisting of all characters after (but not including)
     * the string quote character, up to (but not including) the next
     * occurrence of that same string quote character, or a line
     * terminator, or end of file. The usual escape sequences such as
     * <code>"&#92;n"</code> and <code>"&#92;t"</code> are recognized and
     * converted to single characters as the string is parsed.
     *
     * <p>Any other attribute settings for the specified character are cleared.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

public class StreamTokenizer 
ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * The <code>StreamTokenizer</code> class takes an input stream and
 * parses it into "tokens", allowing the tokens to be
 * read one at a time. The parsing process is controlled by a table
 * and a number of flags that can be set to various states. The
 * stream tokenizer can recognize identifiers, numbers, quoted
 * strings, and various comment styles.
 * <p>
 * Each byte read from the input stream is regarded as a character
 * in the range <code>'&#92;u0000'</code> through <code>'&#92;u00FF'</code>.
 * The character value is used to look up five possible attributes of
 * the character: <i>white space</i>, <i>alphabetic</i>,
 * <i>numeric</i>, <i>string quote</i>, and <i>comment character</i>.
 * Each character can have zero or more of these attributes.
 * <p>
 * In addition, an instance has four flags. These flags indicate:
 * <ul>
 * <li>Whether line terminators are to be returned as tokens or treated
 *     as white space that merely separates tokens.
 * <li>Whether C-style comments are to be recognized and skipped.
 * <li>Whether C++-style comments are to be recognized and skipped.
 * <li>Whether the characters of identifiers are converted to lowercase.
 * </ul>
 * <p>
 * A typical application first constructs an instance of this class,
 * sets up the syntax tables, and then repeatedly loops calling the
 * <code>nextToken</code> method in each iteration of the loop until
 * it returns the value <code>TT_EOF</code>.
 * {@description.close}
 *
 
~
DESC BLOCK::: * {@description.open}
 * The <code>StreamTokenizer</code> class takes an input stream and
 * parses it into "tokens", allowing the tokens to be
 * read one at a time. The parsing process is controlled by a table
 * and a number of flags that can be set to various states. The
 * stream tokenizer can recognize identifiers, numbers, quoted
 * strings, and various comment styles.
 * <p>
 * Each byte read from the input stream is regarded as a character
 * in the range <code>'&#92;u0000'</code> through <code>'&#92;u00F
...
ely separates tokens.
 * <li>Whether C-style comments are to be recognized and skipped.
 * <li>Whether C++-style comments are to be recognized and skipped.
 * <li>Whether the characters of identifiers are converted to lowercase.
 * </ul>
 * <p>
 * A typical application first constructs an instance of this class,
 * sets up the syntax tables, and then repeatedly loops calling the
 * <code>nextToken</code> method in each iteration of the loop until
 * it returns the value <code>TT_EOF</code>.
 * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    @Deprecated
    public StreamTokenizer(InputStream is) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a stream tokenizer that parses the specified input
     * stream. The stream tokenizer is initialized to the following
     * default state:
     * <ul>
     * <li>All byte values <code>'A'</code> through <code>'Z'</code>,
     *     <code>'a'</code> through <code>'z'</code>, and
     *     <code>'&#92;u00A0'</code> through <code>'&#92;u00FF'</code> are
     *     considered to be alphabetic.
     * <li>All byte values <code>'&#92;u0000'</code> through
     *     <code>'&#92;u0020'</code> are considered to be white space.
     * <li><code>'/'</code> is a comment character.
     * <li>Single quote <code>'&#92;''</code> and double quote <code>'"'</code>
     *     are string quote characters.
     * <li>Numbers are parsed.
     * <li>Ends of lines are treated as white space, not as separate tokens.
     * <li>C-style and C++-style comments are not recognized.
     * </ul>
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a stream tokenizer that parses the specified input
     * stream. The stream tokenizer is initialized to the following
     * default state:
     * <ul>
     * <li>All byte values <code>'A'</code> through <code>'Z'</code>,
     *     <code>'a'</code> through <code>'z'</code>, and
     *     <code>'&#92;u00A0'</code> through <code>'&#92;u00FF'</code> are
     *     considered to be alphabetic.
     * <li>All byte values <code>'&#92;u0000'</code> through
     *     <code>'&#92;u0020'</code> are considered to be white space.
     * <li><code>'/'</code> is a comment character.
     * <li>Single quote <code>'&#92;''</code> and double quote <code>'"'</code>
     *     are string quote characters.
     * <li>Numbers are parsed.
     * <li>Ends of lines are treated as white space, not as separate tokens.
     * <li>C-style and C++-style comments are not recognized.
     * </ul>
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FileInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until some input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until some input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public FileInputStream(FileDescriptor fdObj) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a <code>FileInputStream</code> by using the file descriptor
     * <code>fdObj</code>, which represents an existing connection to an
     * actual file in the file system.
     * <p>
     * If there is a security manager, its <code>checkRead</code> method is
     * called with the file descriptor <code>fdObj</code> as its argument to
     * see if it's ok to read the file descriptor. If read access is denied
     * to the file descriptor a <code>SecurityException</code> is thrown.
     * <p>
     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
     * is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a <code>FileInputStream</code> by using the file descriptor
     * <code>fdObj</code>, which represents an existing connection to an
     * actual file in the file system.
     * <p>
     * If there is a security manager, its <code>checkRead</code> method is
     * called with the file descriptor <code>fdObj</code> as its argument to
     * see if it's ok to read the file descriptor. If read access is denied
     * to the file descriptor a <code>SecurityException</code> is thrown.
     * <p>
     * If <code>fdObj</code> is null then a <code>NullPointerException</code>
     * is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>b.length</code> bytes of data from this input
     * stream into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until some input
     * is available.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>b.length</code> bytes of data from this input
     * stream into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until some input
     * is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public native int read() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a byte of data from this input stream.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks
     * if no input is yet available.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a byte of data from this input stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks
     * if no input is yet available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public native int available() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open blocking}
     * Returns an estimate of the number of remaining bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream.
     * {@description.close}
     * {@description.open}
     * The next invocation might be
     * the same thread or another thread.  A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     *
     * <p> In some cases, a non-blocking read (or skip) may appear to be
     * blocked when it is merely slow, for example when reading large
     * files over slow networks.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open blocking}
     * Returns an estimate of the number of remaining bytes that can be read (or
     * skipped over) from this input stream without blocking by the next
     * invocation of a method for this input stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * The next invocation might be
     * the same thread or another thread.  A single read or skip of this
     * many bytes will not block, but may read or skip fewer bytes.
     *
     * <p> In some cases, a non-blocking read (or skip) may appear to be
     * blocked when it is merely slow, for example when reading large
     * files over slow networks.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public native long skip(long n) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Skips over and discards <code>n</code> bytes of data from the
     * input stream.
     *
     * <p>The <code>skip</code> method may, for a variety of
     * reasons, end up skipping over some smaller number of bytes,
     * possibly <code>0</code>. If <code>n</code> is negative, an
     * <code>IOException</code> is thrown, even though the <code>skip</code>
     * method of the {@link InputStream} superclass does nothing in this case.
     * The actual number of bytes skipped is returned.
     *
     * <p>This method may skip more bytes than are remaining in the backing
     * file. This produces no exception and the number of bytes skipped
     * may include some number of bytes that were beyond the EOF of the
     * backing file. Attempting to read from the stream after skipping past
     * the end will result in -1 indicating the end of the file.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Skips over and discards <code>n</code> bytes of data from the
     * input stream.
     *
     * <p>The <code>skip</code> method may, for a variety of
     * reasons, end up skipping over some smaller number of bytes,
     * possibly <code>0</code>. If <code>n</code> is negative, an
     * <code>IOException</code> is thrown, even though the <code>skip</code>
     * method of the {@link InputStream} superclass does nothing in this case.
     * The actual number of bytes skipped is returned.
     *
     * <p>This method may skip more bytes than are remaining in the backing
     * file. This produces no exception and the number of bytes skipped
     * may include some number of bytes that were beyond the EOF of the
     * backing file. Attempting to read from the stream after skipping past
     * the end will result in -1 indicating the end of the file.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: ByteArrayOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public synchronized String toString(String charsetName)
        throws UnsupportedEncodingException
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Converts the buffer's contents into a string by decoding the bytes using
     * the specified {@link java.nio.charset.Charset charsetName}. The length of
     * the new <tt>String</tt> is a function of the charset, and hence may not be
     * equal to the length of the byte array.
     *
     * <p> This method always replaces malformed-input and unmappable-character
     * sequences with this charset's default replacement string. The {@link
     * java.nio.charset.CharsetDecoder} class should be used when more control
     * over the decoding process is required.
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Converts the buffer's contents into a string by decoding the bytes using
     * the specified {@link java.nio.charset.Charset charsetName}. The length of
     * the new <tt>String</tt> is a function of the charset, and hence may not be
     * equal to the length of the byte array.
     *
     * <p> This method always replaces malformed-input and unmappable-character
     * sequences with this charset's default replacement string. The {@link
     * java.nio.charset.CharsetDecoder} class should be used when more control
     * over the decoding process is required.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    @Deprecated
    public synchronized String toString(int hibyte) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a newly allocated string. Its size is the current size of
     * the output stream and the valid contents of the buffer have been
     * copied into it. Each character <i>c</i> in the resulting string is
     * constructed from the corresponding element <i>b</i> in the byte
     * array such that:
     * <blockquote><pre>
     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
     * </pre></blockquote>
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
NEAREST SIGNATURE::: 
    public synchronized byte toByteArray()[] 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a newly allocated byte array. Its size is the current
     * size of this output stream and the valid contents of the buffer
     * have been copied into it.
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
ADDRESSED PROP::: [x]
---------
NEAREST SIGNATURE::: 
    public synchronized void writeTo(OutputStream out) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes the complete contents of this byte array output stream to
     * the specified output stream argument, as if by calling the output
     * stream's write method using <code>out.write(buf, 0, count)</code>.
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * When an OutputStream (or its subclass) instance is built on top of an
     * underlying ByteArrayOutputStream instance, it should be flushed or closed
     * before the contents of the ByteArrayOutputStream instance is retrieved.
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * When an OutputStream (or its subclass) instance is built on top of an
     * underlying ByteArrayOutputStream instance, it should be flushed or closed
     * before the contents of the ByteArrayOutputStream instance is retrieved.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Writes the complete contents of this byte array output stream to
     * the specified output stream argument, as if by calling the output
     * stream's write method using <code>out.write(buf, 0, count)</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public synchronized String toString() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Converts the buffer's contents into a string decoding bytes using the
     * platform's default character set. The length of the new <tt>String</tt>
     * is a function of the character set, and hence may not be equal to the
     * size of the buffer.
     *
     * <p> This method always replaces malformed-input and unmappable-character
     * sequences with the default replacement string for the platform's
     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
     * class should be used when more control over the decoding process is
     * required.
     * {@description.close}
     *
     * {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
     *
     
~
PROP BLOCK:::* {@property.open runtime formal:java.io.ByteArrayOutputStream_FlushBeforeRetrieve}
     * {@property.close}
ADDRESSED PROP::: []
---------
FILE: ObjectStreamClass.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
        private final char[] typeCodes;
        /** 
ORIG COMMENT::: /** {@collect.stats}
         * {@description.open}
         * unsafe fields keys for writing fields - no dupes 
         * {@description.close}
         / 
        private final long[] writeKeys;
        /** {@collect.stats}
         * {@description.open}
         * field data offsets
         * {@description.close}
         */
~
DESC BLOCK::: * {@description.open}
         * unsafe fields keys for writing fields - no dupes 
         * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
         * field data offsets
         * {@description.close}
ADDRESSED DESC::: []
---------
FILE: StreamCorruptedException.java
DIRECTORY: java/io
FILE: ByteArrayInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public synchronized int read(byte b[], int off, int len) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data into an array of bytes
     * from this input stream.
     * If <code>pos</code> equals <code>count</code>,
     * then <code>-1</code> is returned to indicate
     * end of file. Otherwise, the  number <code>k</code>
     * of bytes read is equal to the smaller of
     * <code>len</code> and <code>count-pos</code>.
     * If <code>k</code> is positive, then bytes
     * <code>buf[pos]</code> through <code>buf[pos+k-1]</code>
     * are copied into <code>b[off]</code>  through
     * <code>b[off+k-1]</code> in the manner performed
     * by <code>System.arraycopy</code>. The
     * value <code>k</code> is added into <code>pos</code>
     * and <code>k</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * <p>
     * This <code>read</code> method cannot block.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data into an array of bytes
     * from this input stream.
     * If <code>pos</code> equals <code>count</code>,
     * then <code>-1</code> is returned to indicate
     * end of file. Otherwise, the  number <code>k</code>
     * of bytes read is equal to the smaller of
     * <code>len</code> and <code>count-pos</code>.
     * If <code>k</code> is positive, then bytes
     * <code>buf[pos]</code> through <code>buf[pos+k-1]</code>
     * are copied into <code>b[off]</code>  through
     * <code>b[off+k-1]</code> in the manner performed
     * by <code>System.arraycopy</code>. The
     * value <code>k</code> is added into <code>pos</code>
     * and <code>k</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p>
     * This <code>read</code> method cannot block.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public synchronized int read() 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * <p>
     * This <code>read</code> method
     * cannot block.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p>
     * This <code>read</code> method
     * cannot block.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: PrintWriter.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void println(boolean x) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Terminates the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * <code>line.separator</code>, and is not necessarily a single newline
     * character (<code>'\n'</code>).
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * Terminates the current line by writing the line separator string.  The
     * line separator string is defined by the system property
     * <code>line.separator</code>, and is not necessarily a single newline
     * character (<code>'\n'</code>).
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: InputStreamReader.java
DIRECTORY: java/io
FILE: LineNumberReader.java
DIRECTORY: java/io
FILE: StringWriter.java
DIRECTORY: java/io
FILE: FileWriter.java
DIRECTORY: java/io
FILE: SerializablePermission.java
DIRECTORY: java/io
FILE: Console.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 

public final class Console implements Flushable

ORIG COMMENT::: /** {@collect.stats}
 *
 * {@description.open}
 * Methods to access the character-based console device, if any, associated
 * with the current Java virtual machine.
 *
 * <p> Whether a virtual machine has a console is dependent upon the
 * underlying platform and also upon the manner in which the virtual
 * machine is invoked.  If the virtual machine is started from an
 * interactive command line without redirecting the standard input and
 * output streams then its console will exist and will typically be
 * connected to the keyboard and display from which the virtual machine
 * was launched.  If the virtual machine is started automatically, for
 * example by a background job scheduler, then it will typically not
 * have a console.
 * {@description.close}
 * {@property.open}
 * <p>
 * If this virtual machine has a console then it is represented by a
 * unique instance of this class which can be obtained by invoking the
 * {@link java.lang.System#console()} method.  If no console device is
 * available then an invocation of that method will return <tt>null</tt>.
 * {@property.close}
 * {@description.open blocking}
 * <p>
 * Read and write operations are synchronized to guarantee the atomic
 * completion of critical operations; therefore invoking methods
 * {@link #readLine()}, {@link #readPassword()}, {@link #format format()},
 * {@link #printf printf()} as well as the read, format and write operations
 * on the objects returned by {@link #reader()} and {@link #writer()} may
 * block in multithreaded scenarios.
 * {@description.close}
 * {@property.open runtime formal:java.io.Console_CloseReader formal:java.io.Console_CloseWriter}
 * <p>
 * Invoking <tt>close()</tt> on the objects returned by the {@link #reader()}
 * and the {@link #writer()} will not close the underlying stream of those
 * objects.
 * {@property.close}
 * {@description.open}
 * <p>
 * The console-read methods return <tt>null</tt> when the end of the
 * console input stream is reached, for example by typing control-D on
 * Unix or control-Z on Windows.  Subsequent read operations will succeed
 * if additional characters are later entered on the console's input
 * device.
 * <p>
 * Unless otherwise specified, passing a <tt>null</tt> argument to any method
 * in this class will cause a {@link NullPointerException} to be thrown.
 * {@description.close}
 * {@property.open}
 * <p>
 * <b>Security note:</b>
 * If an application needs to read a password or other secure data, it should
 * use {@link #readPassword()} or {@link #readPassword(String, Object...)}
 * {@property.close}
 * {@property.open runtime formal:java.io.Console_FillZeroPassword}
 * and
 * manually zero the returned character array after processing to minimize the
 * lifetime of sensitive data in memory.
 *
 * <blockquote><pre>
 * Console cons;
 * char[] passwd;
 * if ((cons = System.console()) != null &&
 *     (passwd = cons.readPassword("[%s]", "Password:")) != null) {
 *     ...
 *     java.util.Arrays.fill(passwd, ' ');
 * }
 * </pre></blockquote>
 * {@property.close}
 *
 
~
PROP BLOCK:::* {@property.open}
 * <p>
 * If this virtual machine has a console then it is represented by a
 * unique instance of this class which can be obtained by invoking the
 * {@link java.lang.System#console()} method.  If no console device is
 * available then an invocation of that method will return <tt>null</tt>.
 * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open runtime formal:java.io.Console_CloseReader formal:java.io.Console_CloseWriter}
 * <p>
 * Invoking <tt>close()</tt> on the objects returned by the {@link #reader()}
 * and the {@link #writer()} will not close the underlying stream of those
 * objects.
 * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open}
 * <p>
 * <b>Security note:</b>
 * If an application needs to read a password or other secure data, it should
 * use {@link #readPassword()} or {@link #readPassword(String, Object...)}
 * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open runtime formal:java.io.Console_FillZeroPassword}
 * and
 * manually zero the returned character array after processing to minimize the
 * lifetime of sensitive data in memory.
 *
 * <blockquote><pre>
 * Console cons;
 * char[] passwd;
 * if ((cons = System.console()) != null &&
 *     (passwd = cons.readPassword("[%s]", "Password:")) != null) {
 *     ...
 *     java.util.Arrays.fill(passwd, ' ');
 * }
 * </pre></blockquote>
 * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
 * Methods to access the character-based console device, if any, associated
 * with the current Java virtual machine.
 *
 * <p> Whether a virtual machine has a console is dependent upon the
 * underlying platform and also upon the manner in which the virtual
 * machine is invoked.  If the virtual machine is started from an
 * interactive command line without redirecting the standard input and
 * output streams then its console will exist and will typically be
 * connected to the keyboard and display from which the virtual machine
 * was launched.  If the virtual machine is started automatically, for
 * example by a background job scheduler, then it will typically not
 * have a console.
 * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
 * <p>
 * Read and write operations are synchronized to guarantee the atomic
 * completion of critical operations; therefore invoking methods
 * {@link #readLine()}, {@link #readPassword()}, {@link #format format()},
 * {@link #printf printf()} as well as the read, format and write operations
 * on the objects returned by {@link #reader()} and {@link #writer()} may
 * block in multithreaded scenarios.
 * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
 * <p>
 * The console-read methods return <tt>null</tt> when the end of the
 * console input stream is reached, for example by typing control-D on
 * Unix or control-Z on Windows.  Subsequent read operations will succeed
 * if additional characters are later entered on the console's input
 * device.
 * <p>
 * Unless otherwise specified, passing a <tt>null</tt> argument to any method
 * in this class will cause a {@link NullPointerException} to be thrown.
 * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public Reader reader() 
ORIG COMMENT::: /** {@collect.stats}
    * {@description.open}
    * Retrieves the unique {@link java.io.Reader Reader} object associated
    * with this console.
    * <p>
    * This method is intended to be used by sophisticated applications, for
    * example, a {@link java.util.Scanner} object which utilizes the rich
    * parsing/scanning functionality provided by the <tt>Scanner</tt>:
    * <blockquote><pre>
    * Console con = System.console();
    * if (con != null) {
    *     Scanner sc = new Scanner(con.reader());
    *     ...
    * }
    * </pre></blockquote>
    * <p>
    * For simple applications requiring only line-oriented reading, use
    * <tt>{@link #readLine}</tt>.
    * {@description.close}
    * {@property.open}
    * <p>
    * The bulk read operations {@link java.io.Reader#read(char[]) read(char[]) },
    * {@link java.io.Reader#read(char[], int, int) read(char[], int, int) } and
    * {@link java.io.Reader#read(java.nio.CharBuffer) read(java.nio.CharBuffer)}
    * on the returned object will not read in characters beyond the line
    * bound for each invocation, even if the destination buffer has space for
    * more characters. A line bound is considered to be any one of a line feed
    * (<tt>'\n'</tt>), a carriage return (<tt>'\r'</tt>), a carriage return
    * followed immediately by a linefeed, or an end of stream.
    * {@property.close}
    *
    
~
PROP BLOCK:::* {@property.open}
    * <p>
    * The bulk read operations {@link java.io.Reader#read(char[]) read(char[]) },
    * {@link java.io.Reader#read(char[], int, int) read(char[], int, int) } and
    * {@link java.io.Reader#read(java.nio.CharBuffer) read(java.nio.CharBuffer)}
    * on the returned object will not read in characters beyond the line
    * bound for each invocation, even if the destination buffer has space for
    * more characters. A line bound is considered to be any one of a line feed
    * (<tt>'\n'</tt>), a carriage return (<tt>'\r'</tt>), a carriage return
    * followed immediately by a linefeed, or an end of stream.
    * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
    * Retrieves the unique {@link java.io.Reader Reader} object associated
    * with this console.
    * <p>
    * This method is intended to be used by sophisticated applications, for
    * example, a {@link java.util.Scanner} object which utilizes the rich
    * parsing/scanning functionality provided by the <tt>Scanner</tt>:
    * <blockquote><pre>
    * Console con = System.console();
    * if (con != null) {
    *     Scanner sc = new Scanner(con.reader());
    *     ...
    * }
    * </pre></blockquote>
    * <p>
    * For simple applications requiring only line-oriented reading, use
    * <tt>{@link #readLine}</tt>.
    * {@description.close}
ADDRESSED DESC::: []
---------
FILE: NotActiveException.java
DIRECTORY: java/io
FILE: WriteAbortedException.java
DIRECTORY: java/io
FILE: DataOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public final void writeBytes(String s) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes out the string to the underlying output stream as a
     * sequence of bytes. Each character in the string is written out, in
     * sequence, by discarding its high eight bits. If no exception is
     * thrown, the counter <code>written</code> is incremented by the
     * length of <code>s</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes out the string to the underlying output stream as a
     * sequence of bytes. Each character in the string is written out, in
     * sequence, by discarding its high eight bits. If no exception is
     * thrown, the counter <code>written</code> is incremented by the
     * length of <code>s</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final void writeChars(String s) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes a string to the underlying output stream as a sequence of
     * characters. Each character is written to the data output stream as
     * if by the <code>writeChar</code> method. If no exception is
     * thrown, the counter <code>written</code> is incremented by twice
     * the length of <code>s</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes a string to the underlying output stream as a sequence of
     * characters. Each character is written to the data output stream as
     * if by the <code>writeChar</code> method. If no exception is
     * thrown, the counter <code>written</code> is incremented by twice
     * the length of <code>s</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: ObjectInput.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a byte of data.
     * {@description.close}
     * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Reads a byte of data.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block if no input is
     * available.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[]) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
     
~
DESC BLOCK::: * {@description.open}
     * Reads into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will
     * block until some input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: ExpiringCache.java
DIRECTORY: java/io
FILE: OptionalDataException.java
DIRECTORY: java/io
FILE: Externalizable.java
DIRECTORY: java/io
FILE: DataInput.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    double readDouble() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads eight input bytes and returns
     * a <code>double</code> value. It does this
     * by first constructing a <code>long</code>
     * value in exactly the manner
     * of the <code>readlong</code>
     * method, then converting this <code>long</code>
     * value to a <code>double</code> in exactly
     * the manner of the method <code>Double.longBitsToDouble</code>.
     * This method is suitable for reading
     * bytes written by the <code>writeDouble</code>
     * method of interface <code>DataOutput</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads eight input bytes and returns
     * a <code>double</code> value. It does this
     * by first constructing a <code>long</code>
     * value in exactly the manner
     * of the <code>readlong</code>
     * method, then converting this <code>long</code>
     * value to a <code>double</code> in exactly
     * the manner of the method <code>Double.longBitsToDouble</code>.
     * This method is suitable for reading
     * bytes written by the <code>writeDouble</code>
     * method of interface <code>DataOutput</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    void readFully(byte b[], int off, int len) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     *
     * {@description.open}
     * Reads <code>len</code>
     * bytes from
     * an input stream.
     * {@description.close}
     * {@description.open blocking}
     * <p>
     * This method
     * blocks until one of the following conditions
     * occurs:<p>
     * <ul>
     * <li><code>len</code> bytes
     * of input data are available, in which case
     * a normal return is made.
     *
     * <li>End of file
     * is detected, in which case an <code>EOFException</code>
     * is thrown.
     *
     * <li>An I/O error occurs, in
     * which case an <code>IOException</code> other
     * than <code>EOFException</code> is thrown.
     * </ul>
     * {@description.close}
     * {@property.open}
     * <p>
     * If <code>b</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * If <code>off</code> is negative, or <code>len</code>
     * is negative, or <code>off+len</code> is
     * greater than the length of the array <code>b</code>,
     * then an <code>IndexOutOfBoundsException</code>
     * is thrown.
     * {@property.close}
     * {@description.open}
     * If <code>len</code> is zero,
     * then no bytes are read. Otherwise, the first
     * byte read is stored into element <code>b[off]</code>,
     * the next one into <code>b[off+1]</code>,
     * and so on. The number of bytes read is,
     * at most, equal to <code>len</code>.
     * {@description.close}
     *
     
~
PROP BLOCK:::* {@property.open}
     * <p>
     * If <code>b</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * If <code>off</code> is negative, or <code>len</code>
     * is negative, or <code>off+len</code> is
     * greater than the length of the array <code>b</code>,
     * then an <code>IndexOutOfBoundsException</code>
     * is thrown.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads <code>len</code>
     * bytes from
     * an input stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p>
     * This method
     * blocks until one of the following conditions
     * occurs:<p>
     * <ul>
     * <li><code>len</code> bytes
     * of input data are available, in which case
     * a normal return is made.
     *
     * <li>End of file
     * is detected, in which case an <code>EOFException</code>
     * is thrown.
     *
     * <li>An I/O error occurs, in
     * which case an <code>IOException</code> other
     * than <code>EOFException</code> is thrown.
     * </ul>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * If <code>len</code> is zero,
     * then no bytes are read. Otherwise, the first
     * byte read is stored into element <code>b[off]</code>,
     * the next one into <code>b[off+1]</code>,
     * and so on. The number of bytes read is,
     * at most, equal to <code>len</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    void readFully(byte b[]) throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads some bytes from an input
     * stream and stores them into the buffer
     * array <code>b</code>. The number of bytes
     * read is equal
     * to the length of <code>b</code>.
     * {@description.close}
     * {@description.open blocking}
     * <p>
     * This method blocks until one of the
     * following conditions occurs:<p>
     * <ul>
     * <li><code>b.length</code>
     * bytes of input data are available, in which
     * case a normal return is made.
     *
     * <li>End of
     * file is detected, in which case an <code>EOFException</code>
     * is thrown.
     *
     * <li>An I/O error occurs, in
     * which case an <code>IOException</code> other
     * than <code>EOFException</code> is thrown.
     * </ul>
     * {@description.close}
     * {@property.open}
     * <p>
     * If <code>b</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * If <code>b.length</code> is zero, then
     * no bytes are read. Otherwise, the first
     * byte read is stored into element <code>b[0]</code>,
     * the next one into <code>b[1]</code>, and
     * so on.
     * {@property.close}
     * {@description.open}
     * If an exception is thrown from
     * this method, then it may be that some but
     * not all bytes of <code>b</code> have been
     * updated with data from the input stream.
     * {@description.close}
     *
     
~
PROP BLOCK:::* {@property.open}
     * <p>
     * If <code>b</code> is <code>null</code>,
     * a <code>NullPointerException</code> is thrown.
     * If <code>b.length</code> is zero, then
     * no bytes are read. Otherwise, the first
     * byte read is stored into element <code>b[0]</code>,
     * the next one into <code>b[1]</code>, and
     * so on.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads some bytes from an input
     * stream and stores them into the buffer
     * array <code>b</code>. The number of bytes
     * read is equal
     * to the length of <code>b</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p>
     * This method blocks until one of the
     * following conditions occurs:<p>
     * <ul>
     * <li><code>b.length</code>
     * bytes of input data are available, in which
     * case a normal return is made.
     *
     * <li>End of
     * file is detected, in which case an <code>EOFException</code>
     * is thrown.
     *
     * <li>An I/O error occurs, in
     * which case an <code>IOException</code> other
     * than <code>EOFException</code> is thrown.
     * </ul>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * If an exception is thrown from
     * this method, then it may be that some but
     * not all bytes of <code>b</code> have been
     * updated with data from the input stream.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    String readLine() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next line of text from the input stream.
     * It reads successive bytes, converting
     * each byte separately into a character,
     * until it encounters a line terminator or
     * end of
     * file; the characters read are then
     * returned as a <code>String</code>.
     * {@description.close}
     * {@property.open}
     * Note
     * that because this
     * method processes bytes,
     * it does not support input of the full Unicode
     * character set.
     * {@property.close}
     * {@property.open}
     * <p>
     * If end of file is encountered
     * before even one byte can be read, then <code>null</code>
     * is returned. Otherwise, each byte that is
     * read is converted to type <code>char</code>
     * by zero-extension. If the character <code>'\n'</code>
     * is encountered, it is discarded and reading
     * ceases. If the character <code>'\r'</code>
     * is encountered, it is discarded and, if
     * the following byte converts &#32;to the
     * character <code>'\n'</code>, then that is
     * discarded also; reading then ceases. If
     * end of file is encountered before either
     * of the characters <code>'\n'</code> and
     * <code>'\r'</code> is encountered, reading
     * ceases. Once reading has ceased, a <code>String</code>
     * is returned that contains all the characters
     * read and not discarded, taken in order.
     * {@property.close}
     * {@description.open}
     * Note that every character in this string
     * will have a value less than <code>&#92;u0100</code>,
     * that is, <code>(char)256</code>.
     * {@description.close}
     *
     
~
PROP BLOCK:::* {@property.open}
     * Note
     * that because this
     * method processes bytes,
     * it does not support input of the full Unicode
     * character set.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open}
     * <p>
     * If end of file is encountered
     * before even one byte can be read, then <code>null</code>
     * is returned. Otherwise, each byte that is
     * read is converted to type <code>char</code>
     * by zero-extension. If the character <code>'\n'</code>
     * is encountered, it is discarded and reading
     * ceases. If the character <code>'\r'</code>
     * is encountered, it is discarded and, if
     * the following byte converts &#32;to the
     * character <code>'\n'</code>, then that is
     * discarded also; reading then ceases. If
     * end of file is encountered before either
     * of the characters <code>'\n'</code> and
     * <code>'\r'</code> is encountered, reading
     * ceases. Once reading has ceased, a <code>String</code>
     * is returned that contains all the characters
     * read and not discarded, taken in order.
     * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
     * Reads the next line of text from the input stream.
     * It reads successive bytes, converting
     * each byte separately into a character,
     * until it encounters a line terminator or
     * end of
     * file; the characters read are then
     * returned as a <code>String</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * Note that every character in this string
     * will have a value less than <code>&#92;u0100</code>,
     * that is, <code>(char)256</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
public
interface DataInput 
ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * The <code>DataInput</code> interface provides
 * for reading bytes from a binary stream and
 * reconstructing from them data in any of
 * the Java primitive types. There is also
 * a
 * facility for reconstructing a <code>String</code>
 * from data in
 * <a href="#modified-utf-8">modified UTF-8</a>
 * format.
 * <p>
 * It is generally true of all the reading
 * routines in this interface that if end of
 * file is reached before the desired number
 * of bytes has been read, an <code>EOFException</code>
 * (which is a kind of <code>IOException</code>)
 * is thrown. If any byte cannot be read for
 * any reason other than end of file, an <code>IOException</code>
 * other than <code>EOFException</code> is
 * thrown. In particular, an <code>IOException</code>
 * may be thrown if the input stream has been
 * closed.
 * {@description.close}
 *
 * {@property.open}
 * <h4><a name="modified-utf-8">Modified UTF-8</a></h4>
 * <p>
 * Implementations of the DataInput and DataOutput interfaces represent
 * Unicode strings in a format that is a slight modification of UTF-8.
 * (For information regarding the standard UTF-8 format, see section
 * <i>3.9 Unicode Encoding Forms</i> of <i>The Unicode Standard, Version
 * 4.0</i>).
 * Note that in the following tables, the most significant bit appears in the
 * far left-hand column.
 * <p>
 * All characters in the range <code>'&#92;u0001'</code> to
 * <code>'&#92;u007F'</code> are represented by a single byte:
 *
 * <blockquote>
 *   <table border="1" cellspacing="0" cellpadding="8" width="50%"
 *          summary="Bit values and bytes">
 *     <tr>
 *       <td></td>
 *       <th id="bit">Bit Values</th>
 *     </tr>
 *     <tr>
 *       <th id="byte1">Byte 1</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>0</center>
 *             <td colspan="7"><center>bits 6-0</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *   </table>
 * </blockquote>
 *
 * <p>
 * The null character <code>'&#92;u0000'</code> and characters in the
 * range <code>'&#92;u0080'</code> to <code>'&#92;u07FF'</code> are
 * represented by a pair of bytes:
 *
 * <blockquote>
 *   <table border="1" cellspacing="0" cellpadding="8" width="50%"
 *          summary="Bit values and bytes">
 *     <tr>
 *       <td></td>
 *       <th id="bit">Bit Values</th>
 *     </tr>
 *     <tr>
 *       <th id="byte1">Byte 1</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>1</center>
 *             <td width="12%"><center>0</center>
 *             <td colspan="5"><center>bits 10-6</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *     <tr>
 *       <th id="byte2">Byte 2</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>0</center>
 *             <td colspan="6"><center>bits 5-0</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *   </table>
 *  </blockquote>
 *
 * <br>
 * <code>char</code> values in the range <code>'&#92;u0800'</code> to
 * <code>'&#92;uFFFF'</code> are represented by three bytes:
 *
 * <blockquote>
 *   <table border="1" cellspacing="0" cellpadding="8" width="50%"
 *          summary="Bit values and bytes">
 *     <tr>
 *       <td></td>
 *       <th id="bit">Bit Values</th>
 *     </tr>
 *     <tr>
 *       <th id="byte1">Byte 1</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>1</center>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>0</center>
 *             <td colspan="4"><center>bits 15-12</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *     <tr>
 *       <th id="byte2">Byte 2</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>0</center>
 *             <td colspan="6"><center>bits 11-6</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *     <tr>
 *       <th id="byte3">Byte 3</th>
 *       <td>
 *         <table border="1" cellspacing="0" width="100%">
 *           <tr>
 *             <td width="12%"><center>1</center>
 *             <td width="13%"><center>0</center>
 *             <td colspan="6"><center>bits 5-0</center>
 *           </tr>
 *         </table>
 *       </td>
 *     </tr>
 *   </table>
 *  </blockquote>
 *
 * <p>
 * The differences between this format and the
 * standard UTF-8 format are the following:
 * <ul>
 * <li>The null byte <code>'&#92;u0000'</code> is encoded in 2-byte format
 *     rather than 1-byte, so that the encoded strings never have
 *     embedded nulls.
 * <li>Only the 1-byte, 2-byte, and 3-byte formats are used.
 * <li><a href="../lang/Character.html#unicode">Supplementary characters</a>
 *     are represented in the form of surrogate pairs.
 * </ul>
 * {@property.close}
 
~
PROP BLOCK:::* {@property.open}
 * <h4><a name="modified-utf-8">Modified UTF-8</a></h4>
 * <p>
 * Implementations of the DataInput and DataOutput interfaces represent
 * Unicode strings in a format that is a slight modification of UTF-8.
 * (For information regarding the standard UTF-8 format, see section
 * <i>3.9 Unicode Encoding Forms</i> of <i>The Unicode Standard, Version
 * 4.0</i>).
 * Note that in the following tables, the most significant bit appears in the
 * far left-hand column.
 * <p>
 * All characters in the r
...
e>
 *  </blockquote>
 *
 * <p>
 * The differences between this format and the
 * standard UTF-8 format are the following:
 * <ul>
 * <li>The null byte <code>'&#92;u0000'</code> is encoded in 2-byte format
 *     rather than 1-byte, so that the encoded strings never have
 *     embedded nulls.
 * <li>Only the 1-byte, 2-byte, and 3-byte formats are used.
 * <li><a href="../lang/Character.html#unicode">Supplementary characters</a>
 *     are represented in the form of surrogate pairs.
 * </ul>
 * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
 * The <code>DataInput</code> interface provides
 * for reading bytes from a binary stream and
 * reconstructing from them data in any of
 * the Java primitive types. There is also
 * a
 * facility for reconstructing a <code>String</code>
 * from data in
 * <a href="#modified-utf-8">modified UTF-8</a>
 * format.
 * <p>
 * It is generally true of all the reading
 * routines in this interface that if end of
 * file is reached before the desired number
 * of bytes has been read, an <code>EOFException</code>
 * (which is a kind of <code>IOException</code>)
 * is thrown. If any byte cannot be read for
 * any reason other than end of file, an <code>IOException</code>
 * other than <code>EOFException</code> is
 * thrown. In particular, an <code>IOException</code>
 * may be thrown if the input stream has been
 * closed.
 * {@description.close}
ADDRESSED DESC::: []
---------
FILE: CharArrayReader.java
DIRECTORY: java/io
FILE: ObjectOutputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public void reset() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reset will disregard the state of any objects already written to the
     * stream.  The state is reset to be the same as a new ObjectOutputStream.
     * The current point in the stream is marked as reset so the corresponding
     * ObjectInputStream will be reset at the same point.  Objects previously
     * written to the stream will not be refered to as already being in the
     * stream.  They will be written to the stream again.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reset will disregard the state of any objects already written to the
     * stream.  The state is reset to be the same as a new ObjectOutputStream.
     * The current point in the stream is marked as reset so the corresponding
     * ObjectInputStream will be reset at the same point.  Objects previously
     * written to the stream will not be refered to as already being in the
     * stream.  They will be written to the stream again.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void write(int val) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes a byte.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until the byte is actually
     * written.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes a byte.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until the byte is actually
     * written.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public void write(byte[] buf) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Writes an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until the bytes are
     * actually written.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Writes an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until the bytes are
     * actually written.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FilePermission.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 

    public FilePermission(String path, String actions)
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a new FilePermission object with the specified actions.
     * <i>path</i> is the pathname of a file or directory, and <i>actions</i>
     * contains a comma-separated list of the desired actions granted on the
     * file or directory. Possible actions are
     * "read", "write", "execute", and "delete".
     *
     * <p>A pathname that ends in "/*" (where "/" is
     * the file separator character, <code>File.separatorChar</code>)
     * indicates all the files and directories contained in that directory.
     * A pathname that ends with "/-" indicates (recursively) all files and
     * subdirectories contained in that directory. The special pathname
     * "&lt;&lt;ALL FILES&gt;&gt;" matches any file.
     *
     * <p>A pathname consisting of a single "*" indicates all the files
     * in the current directory, while a pathname consisting of a single "-"
     * indicates all the files in the current directory and
     * (recursively) all files and subdirectories contained in the current
     * directory.
     *
     * <p>A pathname containing an empty string represents an empty path.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a new FilePermission object with the specified actions.
     * <i>path</i> is the pathname of a file or directory, and <i>actions</i>
     * contains a comma-separated list of the desired actions granted on the
     * file or directory. Possible actions are
     * "read", "write", "execute", and "delete".
     *
     * <p>A pathname that ends in "/*" (where "/" is
     * the file separator character, <code>File.separatorChar</code>)
     * indicates all the files and directorie
...
ontained in that directory. The special pathname
     * "&lt;&lt;ALL FILES&gt;&gt;" matches any file.
     *
     * <p>A pathname consisting of a single "*" indicates all the files
     * in the current directory, while a pathname consisting of a single "-"
     * indicates all the files in the current directory and
     * (recursively) all files and subdirectories contained in the current
     * directory.
     *
     * <p>A pathname containing an empty string represents an empty path.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    private final static int NONE    = 0x0;

    // the actions mask
    private transient int mask;

    // does path indicate a directory? (wildcard or recursive)
    private transient boolean directory;

    // is it a recursive directory specification?
    private transient boolean recursive;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * All actions (read,write,execute,delete)
     * {@description.close}
     */
~
DESC BLOCK::: * {@description.open}
     * All actions (read,write,execute,delete)
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

    public void add(Permission permission)
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Create an empty FilePermissions object.
     * {@description.close}
     *
     */
~
DESC BLOCK::: * {@description.open}
     * Create an empty FilePermissions object.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public String getActions()
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Returns the "canonical string representation" of the actions.
     * That is, this method always returns present actions in the following order:
     * read, write, execute, delete. For example, if this FilePermission object
     * allows both write and read actions, a call to <code>getActions</code>
     * will return the string "read,write".
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Returns the "canonical string representation" of the actions.
     * That is, this method always returns present actions in the following order:
     * read, write, execute, delete. For example, if this FilePermission object
     * allows both write and read actions, a call to <code>getActions</code>
     * will return the string "read,write".
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public boolean implies(Permission p) 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Checks if this FilePermission object "implies" the specified permission.
     * <P>
     * More specifically, this method returns true if:<p>
     * <ul>
     * <li> <i>p</i> is an instanceof FilePermission,<p>
     * <li> <i>p</i>'s actions are a proper subset of this
     * object's actions, and <p>
     * <li> <i>p</i>'s pathname is implied by this object's
     *      pathname. For example, "/tmp/*" implies "/tmp/foo", since
     *      "/tmp/*" encompasses all files in the "/tmp" directory,
     *      including the one named "foo".
     * </ul>
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Checks if this FilePermission object "implies" the specified permission.
     * <P>
     * More specifically, this method returns true if:<p>
     * <ul>
     * <li> <i>p</i> is an instanceof FilePermission,<p>
     * <li> <i>p</i>'s actions are a proper subset of this
     * object's actions, and <p>
     * <li> <i>p</i>'s pathname is implied by this object's
     *      pathname. For example, "/tmp/*" implies "/tmp/foo", since
     *      "/tmp/*" encompasses all files in the "/tmp" directory,
     *      including the one named "foo".
     * </ul>
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

    public void add(Permission permission)
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Adds a permission to the FilePermissions. The key for the hash is
     * permission.path.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Adds a permission to the FilePermissions. The key for the hash is
     * permission.path.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    private static String getActions(int mask)
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Return the canonical string representation of the actions.
     * Always returns present actions in the following order:
     * read, write, execute, delete.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Return the canonical string representation of the actions.
     * Always returns present actions in the following order:
     * read, write, execute, delete.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

public final class FilePermission extends Permission implements Serializable 
ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * This class represents access to a file or directory.  A FilePermission consists
 * of a pathname and a set of actions valid for that pathname.
 * <P>
 * Pathname is the pathname of the file or directory granted the specified
 * actions. A pathname that ends in "/*" (where "/" is
 * the file separator character, <code>File.separatorChar</code>) indicates
 * all the files and directories contained in that directory. A pathname
 * that ends with "/-" indicates (recursively) all files
 * and subdirectories contained in that directory. A pathname consisting of
 * the special token "&lt;&lt;ALL FILES&gt;&gt;" matches <b>any</b> file.
 * <P>
 * Note: A pathname consisting of a single "*" indicates all the files
 * in the current directory, while a pathname consisting of a single "-"
 * indicates all the files in the current directory and
 * (recursively) all files and subdirectories contained in the current
 * directory.
 * <P>
 * The actions to be granted are passed to the constructor in a string containing
 * a list of one or more comma-separated keywords. The possible keywords are
 * "read", "write", "execute", and "delete". Their meaning is defined as follows:
 * <P>
 * <DL>
 *    <DT> read <DD> read permission
 *    <DT> write <DD> write permission
 *    <DT> execute
 *    <DD> execute permission. Allows <code>Runtime.exec</code> to
 *         be called. Corresponds to <code>SecurityManager.checkExec</code>.
 *    <DT> delete
 *    <DD> delete permission. Allows <code>File.delete</code> to
 *         be called. Corresponds to <code>SecurityManager.checkDelete</code>.
 * </DL>
 * <P>
 * The actions string is converted to lowercase before processing.
 * <P>
 * Be careful when granting FilePermissions. Think about the implications
 * of granting read and especially write access to various files and
 * directories. The "&lt;&lt;ALL FILES>>" permission with write action is
 * especially dangerous. This grants permission to write to the entire
 * file system. One thing this effectively allows is replacement of the
 * system binary, including the JVM runtime environment.
 *
 * <p>Please note: Code can always read a file from the same
 * directory it's in (or a subdirectory of that directory); it does not
 * need explicit permission to do so.
 * {@description.close}
 *
 
~
DESC BLOCK::: * {@description.open}
 * This class represents access to a file or directory.  A FilePermission consists
 * of a pathname and a set of actions valid for that pathname.
 * <P>
 * Pathname is the pathname of the file or directory granted the specified
 * actions. A pathname that ends in "/*" (where "/" is
 * the file separator character, <code>File.separatorChar</code>) indicates
 * all the files and directories contained in that directory. A pathname
 * that ends with "/-" indicates (recursively) all files
 * and s
...
nd especially write access to various files and
 * directories. The "&lt;&lt;ALL FILES>>" permission with write action is
 * especially dangerous. This grants permission to write to the entire
 * file system. One thing this effectively allows is replacement of the
 * system binary, including the JVM runtime environment.
 *
 * <p>Please note: Code can always read a file from the same
 * directory it's in (or a subdirectory of that directory); it does not
 * need explicit permission to do so.
 * {@description.close}
ADDRESSED DESC::: []
---------
FILE: SequenceInputStream.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until at least 1 byte of input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
     * {@description.open}
     * <p>
     * The <code>read</code> method of <code>SequenceInputStream</code>
     * tries to read the data from the current substream. If it fails to
     * read any characters because the substream has reached the end of
     * the stream, it calls the <code>close</code> method of the current
     * substream and begins reading from the next substream.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * If <code>len</code> is not zero, the method
     * blocks until at least 1 byte of input is available; otherwise, no
     * bytes are read and <code>0</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * The <code>read</code> method of <code>SequenceInputStream</code>
     * tries to read the data from the current substream. If it fails to
     * read any characters because the substream has reached the end of
     * the stream, it calls the <code>close</code> method of the current
     * substream and begins reading from the next substream.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next byte of data from this input stream. The byte is
     * returned as an <code>int</code> in the range <code>0</code> to
     * <code>255</code>. If no byte is available because the end of the
     * stream has been reached, the value <code>-1</code> is returned.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until input data is available, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     * {@description.open}
     * <p>
     * This method
     * tries to read one character from the current substream. If it
     * reaches the end of the stream, it calls the <code>close</code>
     * method of the current substream and begins reading from the next
     * substream.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next byte of data from this input stream. The byte is
     * returned as an <code>int</code> in the range <code>0</code> to
     * <code>255</code>. If no byte is available because the end of the
     * stream has been reached, the value <code>-1</code> is returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until input data is available, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * This method
     * tries to read one character from the current substream. If it
     * reaches the end of the stream, it calls the <code>close</code>
     * method of the current substream and begins reading from the next
     * substream.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: FileFilter.java
DIRECTORY: java/io
FILE: Serializable.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
public interface Serializable 
ORIG COMMENT::: /** {@collect.stats}
 * {@description.open}
 * Serializability of a class is enabled by the class implementing the
 * java.io.Serializable interface. Classes that do not implement this
 * interface will not have any of their state serialized or
 * deserialized.  All subtypes of a serializable class are themselves
 * serializable.  The serialization interface has no methods or fields
 * and serves only to identify the semantics of being serializable. <p>
 * {@description.close}
 *
 * {@property.open runtime formal:java.io.Serializable_NoArgConstructor}
 * To allow subtypes of non-serializable classes to be serialized, the
 * subtype may assume responsibility for saving and restoring the
 * state of the supertype's public, protected, and (if accessible)
 * package fields.  The subtype may assume this responsibility only if
 * the class it extends has an accessible no-arg constructor to
 * initialize the class's state.  It is an error to declare a class
 * Serializable if this is not the case.  The error will be detected at
 * runtime. <p>
 *
 * During deserialization, the fields of non-serializable classes will
 * be initialized using the public or protected no-arg constructor of
 * the class.  A no-arg constructor must be accessible to the subclass
 * that is serializable.  The fields of serializable subclasses will
 * be restored from the stream. <p>
 * {@property.close}
 *
 * {@description.open}
 * When traversing a graph, an object may be encountered that does not
 * support the Serializable interface. In this case the
 * NotSerializableException will be thrown and will identify the class
 * of the non-serializable object. <p>
 *
 * Classes that require special handling during the serialization and
 * deserialization process must implement special methods with these exact
 * signatures: <p>
 *
 * <PRE>
 * private void writeObject(java.io.ObjectOutputStream out)
 *     throws IOException
 * private void readObject(java.io.ObjectInputStream in)
 *     throws IOException, ClassNotFoundException;
 * private void readObjectNoData()
 *     throws ObjectStreamException;
 * </PRE>
 *
 * <p>The writeObject method is responsible for writing the state of the
 * object for its particular class so that the corresponding
 * readObject method can restore it.  The default mechanism for saving
 * the Object's fields can be invoked by calling
 * out.defaultWriteObject. The method does not need to concern
 * itself with the state belonging to its superclasses or subclasses.
 * State is saved by writing the individual fields to the
 * ObjectOutputStream using the writeObject method or by using the
 * methods for primitive data types supported by DataOutput.
 *
 * <p>The readObject method is responsible for reading from the stream and
 * restoring the classes fields. It may call in.defaultReadObject to invoke
 * the default mechanism for restoring the object's non-static and
 * non-transient fields.  The defaultReadObject method uses information in
 * the stream to assign the fields of the object saved in the stream with the
 * correspondingly named fields in the current object.  This handles the case
 * when the class has evolved to add new fields. The method does not need to
 * concern itself with the state belonging to its superclasses or subclasses.
 * State is saved by writing the individual fields to the
 * ObjectOutputStream using the writeObject method or by using the
 * methods for primitive data types supported by DataOutput.
 *
 * <p>The readObjectNoData method is responsible for initializing the state of
 * the object for its particular class in the event that the serialization
 * stream does not list the given class as a superclass of the object being
 * deserialized.  This may occur in cases where the receiving party uses a
 * different version of the deserialized instance's class than the sending
 * party, and the receiver's version extends classes that are not extended by
 * the sender's version.  This may also occur if the serialization stream has
 * been tampered; hence, readObjectNoData is useful for initializing
 * deserialized objects properly despite a "hostile" or incomplete source
 * stream.
 *
 * <p>Serializable classes that need to designate an alternative object to be
 * used when writing an object to the stream should implement this
 * special method with the exact signature: <p>
 *
 * <PRE>
 * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
 * </PRE><p>
 *
 * This writeReplace method is invoked by serialization if the method
 * exists and it would be accessible from a method defined within the
 * class of the object being serialized. Thus, the method can have private,
 * protected and package-private access. Subclass access to this method
 * follows java accessibility rules. <p>
 *
 * Classes that need to designate a replacement when an instance of it
 * is read from the stream should implement this special method with the
 * exact signature.<p>
 *
 * <PRE>
 * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
 * </PRE><p>
 *
 * This readResolve method follows the same invocation rules and
 * accessibility rules as writeReplace.<p>
 *
 * The serialization runtime associates with each serializable class a version
 * number, called a serialVersionUID, which is used during deserialization to
 * verify that the sender and receiver of a serialized object have loaded
 * classes for that object that are compatible with respect to serialization.
 * If the receiver has loaded a class for the object that has a different
 * serialVersionUID than that of the corresponding sender's class, then
 * deserialization will result in an {@link InvalidClassException}.  A
 * serializable class can declare its own serialVersionUID explicitly by
 * declaring a field named <code>"serialVersionUID"</code> that must be static,
 * final, and of type <code>long</code>:<p>
 *
 * <PRE>
 * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
 * </PRE>
 * {@description.close}
 *
 * {@property.open runtime formal:java.io.Serializable_UID}
 * If a serializable class does not explicitly declare a serialVersionUID, then
 * the serialization runtime will calculate a default serialVersionUID value
 * for that class based on various aspects of the class, as described in the
 * Java(TM) Object Serialization Specification.  However, it is <em>strongly
 * recommended</em> that all serializable classes explicitly declare
 * serialVersionUID values, since the default serialVersionUID computation is
 * highly sensitive to class details that may vary depending on compiler
 * implementations, and can thus result in unexpected
 * <code>InvalidClassException</code>s during deserialization.  Therefore, to
 * guarantee a consistent serialVersionUID value across different java compiler
 * implementations, a serializable class must declare an explicit
 * serialVersionUID value.  It is also strongly advised that explicit
 * serialVersionUID declarations use the <code>private</code> modifier where
 * possible, since such declarations apply only to the immediately declaring
 * class--serialVersionUID fields are not useful as inherited members. Array
 * classes cannot declare an explicit serialVersionUID, so they always have
 * the default computed value, but the requirement for matching
 * serialVersionUID values is waived for array classes.
 * {@new.open}
 * A serializable class should declare a private serialVersionUID explicitly
 * for compatibility.
 * {@new.close}
 * {@property.close}
 *
 
~
PROP BLOCK:::* {@property.open runtime formal:java.io.Serializable_NoArgConstructor}
 * To allow subtypes of non-serializable classes to be serialized, the
 * subtype may assume responsibility for saving and restoring the
 * state of the supertype's public, protected, and (if accessible)
 * package fields.  The subtype may assume this responsibility only if
 * the class it extends has an accessible no-arg constructor to
 * initialize the class's state.  It is an error to declare a class
 * Serializable if this is not the case.  The error will be detected at
 * runtime. <p>
 *
 * During deserialization, the fields of non-serializable classes will
 * be initialized using the public or protected no-arg constructor of
 * the class.  A no-arg constructor must be accessible to the subclass
 * that is serializable.  The fields of serializable subclasses will
 * be restored from the stream. <p>
 * {@property.close}
ADDRESSED PROP::: [x]
---------
PROP BLOCK:::* {@property.open runtime formal:java.io.Serializable_UID}
 * If a serializable class does not explicitly declare a serialVersionUID, then
 * the serialization runtime will calculate a default serialVersionUID value
 * for that class based on various aspects of the class, as described in the
 * Java(TM) Object Serialization Specification.  However, it is <em>strongly
 * recommended</em> that all serializable classes explicitly declare
 * serialVersionUID values, since the default serialVersionUID computation is
...
 modifier where
 * possible, since such declarations apply only to the immediately declaring
 * class--serialVersionUID fields are not useful as inherited members. Array
 * classes cannot declare an explicit serialVersionUID, so they always have
 * the default computed value, but the requirement for matching
 * serialVersionUID values is waived for array classes.
 * {@new.open}
 * A serializable class should declare a private serialVersionUID explicitly
 * for compatibility.
 * {@new.close}
 * {@property.close}
ADDRESSED PROP::: [x]
---------
DESC BLOCK::: * {@description.open}
 * Serializability of a class is enabled by the class implementing the
 * java.io.Serializable interface. Classes that do not implement this
 * interface will not have any of their state serialized or
 * deserialized.  All subtypes of a serializable class are themselves
 * serializable.  The serialization interface has no methods or fields
 * and serves only to identify the semantics of being serializable. <p>
 * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
 * When traversing a graph, an object may be encountered that does not
 * support the Serializable interface. In this case the
 * NotSerializableException will be thrown and will identify the class
 * of the non-serializable object. <p>
 *
 * Classes that require special handling during the serialization and
 * deserialization process must implement special methods with these exact
 * signatures: <p>
 *
 * <PRE>
 * private void writeObject(java.io.ObjectOutputStream out)
 *     throws IOExcep
...
 the receiver has loaded a class for the object that has a different
 * serialVersionUID than that of the corresponding sender's class, then
 * deserialization will result in an {@link InvalidClassException}.  A
 * serializable class can declare its own serialVersionUID explicitly by
 * declaring a field named <code>"serialVersionUID"</code> that must be static,
 * final, and of type <code>long</code>:<p>
 *
 * <PRE>
 * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
 * </PRE>
 * {@description.close}
ADDRESSED DESC::: []
---------
NEW BLOCK:::* {@new.open}
 * A serializable class should declare a private serialVersionUID explicitly
 * for compatibility.
 * {@new.close}
ADDRESSED NEW::: []
---------
FILE: RandomAccessFile.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public final int readUnsignedShort() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads an unsigned 16-bit number from this file. This method reads
     * two bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 8) | b2
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads an unsigned 16-bit number from this file. This method reads
     * two bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 8) | b2
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final long readLong() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code>, <code>b2</code>, <code>b3</code>,
     * <code>b4</code>, <code>b5</code>, <code>b6</code>,
     * <code>b7</code>, and <code>b8,</code> where:
     * <blockquote><pre>
     *     0 &lt;= b1, b2, b3, b4, b5, b6, b7, b8 &lt;=255,
     * </pre></blockquote>
     * <p>
     * then the result is equal to:
     * <p><blockquote><pre>
     *     ((long)b1 &lt;&lt; 56) + ((long)b2 &lt;&lt; 48)
     *     + ((long)b3 &lt;&lt; 40) + ((long)b4 &lt;&lt; 32)
     *     + ((long)b5 &lt;&lt; 24) + ((long)b6 &lt;&lt; 16)
     *     + ((long)b7 &lt;&lt; 8) + b8
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code>, <code>b2</code>, <code>b3</code>,
     * <code>b4</code>, <code>b5</code>, <code>b6</code>,
     * <code>b7</code>, and <code>b8,</code> where:
     * <blockquote><pre>
     *     0 &lt;= b1, b2, b3, b4, b5, b6, b7, b8 &lt;=255,
     * </pre></blockquote>
     * <p>
     * then the result is equal to:
     * <p><blockquote><pre>
     *     ((long)b1 &lt;&lt; 56) + ((long)b2 &lt;&lt; 48)
     *     + ((long)b3 &lt;&lt; 40) + ((long)b4 &lt;&lt; 32)
     *     + ((long)b5 &lt;&lt; 24) + ((long)b6 &lt;&lt; 16)
     *     + ((long)b7 &lt;&lt; 8) + b8
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final double readDouble() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a <code>double</code> from this file. This method reads a
     * <code>long</code> value, starting at the current file pointer,
     * as if by the <code>readLong</code> method
     * and then converts that <code>long</code> to a <code>double</code>
     * using the <code>longBitsToDouble</code> method in
     * class <code>Double</code>.
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a <code>double</code> from this file. This method reads a
     * <code>long</code> value, starting at the current file pointer,
     * as if by the <code>readLong</code> method
     * and then converts that <code>long</code> to a <code>double</code>
     * using the <code>longBitsToDouble</code> method in
     * class <code>Double</code>.
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final short readShort() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a signed 16-bit number from this file. The method reads two
     * bytes from this file, starting at the current file pointer.
     * If the two bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where each of the two values is
     * between <code>0</code> and <code>255</code>, inclusive, then the
     * result is equal to:
     * <blockquote><pre>
     *     (short)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a signed 16-bit number from this file. The method reads two
     * bytes from this file, starting at the current file pointer.
     * If the two bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where each of the two values is
     * between <code>0</code> and <code>255</code>, inclusive, then the
     * result is equal to:
     * <blockquote><pre>
     *     (short)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public native int read() throws IOException;

    /** 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a byte of data from this file. The byte is returned as an
     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>).
     * {@description.close}
     * {@description.open blocking}
     * This
     * method blocks if no input is yet available.
     * {@description.close}
     * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the same
     * way as the {@link InputStream#read()} method of
     * <code>InputStream</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a byte of data from this file. The byte is returned as an
     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>).
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This
     * method blocks if no input is yet available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the same
     * way as the {@link InputStream#read()} method of
     * <code>InputStream</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final void readFully(byte b[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads <code>b.length</code> bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads <code>b.length</code> bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final int readInt() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a signed 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are <code>b1</code>,
     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a signed 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are <code>b1</code>,
     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final int readUnsignedByte() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads an unsigned eight-bit number from this file. This method reads
     * a byte from this file, starting at the current file pointer,
     * and returns that byte.
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads an unsigned eight-bit number from this file. This method reads
     * a byte from this file, starting at the current file pointer,
     * and returns that byte.
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final char readChar() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a character from this file. This method reads two
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (char)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a character from this file. This method reads two
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * <code>b1</code> and <code>b2</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (char)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 

    public final String readLine() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads the next line of text from this file.  This method successively
     * reads bytes from the file, starting at the current file pointer,
     * until it reaches a line terminator or the end
     * of the file.  Each byte is converted into a character by taking the
     * byte's value for the lower eight bits of the character and setting the
     * high eight bits of the character to zero.  This method does not,
     * therefore, support the full Unicode character set.
     *
     * <p> A line of text is terminated by a carriage-return character
     * (<code>'&#92;r'</code>), a newline character (<code>'&#92;n'</code>), a
     * carriage-return character immediately followed by a newline character,
     * or the end of the file.  Line-terminating characters are discarded and
     * are not included as part of the string returned.
     * {@description.close}
     *
     * {@description.open blocking}
     * <p> This method blocks until a newline character is read, a carriage
     * return and the byte following it are read (to see if it is a newline),
     * the end of the file is reached, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads the next line of text from this file.  This method successively
     * reads bytes from the file, starting at the current file pointer,
     * until it reaches a line terminator or the end
     * of the file.  Each byte is converted into a character by taking the
     * byte's value for the lower eight bits of the character and setting the
     * high eight bits of the character to zero.  This method does not,
     * therefore, support the full Unicode character set.
     *
     * <p> A line of text is terminated by a carriage-return character
     * (<code>'&#92;r'</code>), a newline character (<code>'&#92;n'</code>), a
     * carriage-return character immediately followed by a newline character,
     * or the end of the file.  Line-terminating characters are discarded and
     * are not included as part of the string returned.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p> This method blocks until a newline character is read, a carriage
     * return and the byte following it are read (to see if it is a newline),
     * the end of the file is reached, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final float readFloat() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a <code>float</code> from this file. This method reads an
     * <code>int</code> value, starting at the current file pointer,
     * as if by the <code>readInt</code> method
     * and then converts that <code>int</code> to a <code>float</code>
     * using the <code>intBitsToFloat</code> method in class
     * <code>Float</code>.
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a <code>float</code> from this file. This method reads an
     * <code>int</code> value, starting at the current file pointer,
     * as if by the <code>readInt</code> method
     * and then converts that <code>int</code> to a <code>float</code>
     * using the <code>intBitsToFloat</code> method in class
     * <code>Float</code>.
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final void readFully(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads exactly <code>len</code> bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads exactly <code>len</code> bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[], int off, int len) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>len</code> bytes of data from this file into an
     * array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until at least one byte of input
     * is available.
     * {@description.close}
     * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[], int, int)} method of
     * <code>InputStream</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>len</code> bytes of data from this file into an
     * array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until at least one byte of input
     * is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[], int, int)} method of
     * <code>InputStream</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final byte readByte() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a signed eight-bit value from this file. This method reads a
     * byte from the file, starting from the current file pointer.
     * If the byte read is <code>b</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>,
     * then the result is:
     * <blockquote><pre>
     *     (byte)(b)
     * </pre></blockquote>
     * <p>
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a signed eight-bit value from this file. This method reads a
     * byte from the file, starting from the current file pointer.
     * If the byte read is <code>b</code>, where
     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>,
     * then the result is:
     * <blockquote><pre>
     *     (byte)(b)
     * </pre></blockquote>
     * <p>
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final String readUTF() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads in a string from this file. The string has been encoded
     * using a
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * format.
     * <p>
     * The first two bytes are read, starting from the current file
     * pointer, as if by
     * <code>readUnsignedShort</code>. This value gives the number of
     * following bytes that are in the encoded string, not
     * the length of the resulting string. The following bytes are then
     * interpreted as bytes encoding characters in the modified UTF-8 format
     * and are converted into characters.
     * {@description.close}
     * {@description.open blocking}
     * <p>
     * This method blocks until all the bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads in a string from this file. The string has been encoded
     * using a
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * format.
     * <p>
     * The first two bytes are read, starting from the current file
     * pointer, as if by
     * <code>readUnsignedShort</code>. This value gives the number of
     * following bytes that are in the encoded string, not
     * the length of the resulting string. The following bytes are then
     * interpreted as bytes encoding characters in the modified UTF-8 format
     * and are converted into characters.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * <p>
     * This method blocks until all the bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public RandomAccessFile(File file, String mode)
        throws FileNotFoundException
    
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Creates a random access file stream to read from, and optionally to
     * write to, the file specified by the {@link File} argument.  A new {@link
     * FileDescriptor} object is created to represent this file connection.
     *
     * <a name="mode"><p> The <tt>mode</tt> argument specifies the access mode
     * in which the file is to be opened.  The permitted values and their
     * meanings are:
     *
     * <blockquote><table summary="Access mode permitted values and meanings">
     * <tr><th><p align="left">Value</p></th><th><p align="left">Meaning</p></th></tr>
     * <tr><td valign="top"><tt>"r"</tt></td>
     *     <td> Open for reading only.  Invoking any of the <tt>write</tt>
     *     methods of the resulting object will cause an {@link
     *     java.io.IOException} to be thrown. </td></tr>
     * <tr><td valign="top"><tt>"rw"</tt></td>
     *     <td> Open for reading and writing.  If the file does not already
     *     exist then an attempt will be made to create it. </td></tr>
     * <tr><td valign="top"><tt>"rws"</tt></td>
     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
     *     require that every update to the file's content or metadata be
     *     written synchronously to the underlying storage device.  </td></tr>
     * <tr><td valign="top"><tt>"rwd"&nbsp;&nbsp;</tt></td>
     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
     *     require that every update to the file's content be written
     *     synchronously to the underlying storage device. </td></tr>
     * </table></blockquote>
     *
     * The <tt>"rws"</tt> and <tt>"rwd"</tt> modes work much like the {@link
     * java.nio.channels.FileChannel#force(boolean) force(boolean)} method of
     * the {@link java.nio.channels.FileChannel} class, passing arguments of
     * <tt>true</tt> and <tt>false</tt>, respectively, except that they always
     * apply to every I/O operation and are therefore often more efficient.  If
     * the file resides on a local storage device then when an invocation of a
     * method of this class returns it is guaranteed that all changes made to
     * the file by that invocation will have been written to that device.  This
     * is useful for ensuring that critical information is not lost in the
     * event of a system crash.  If the file does not reside on a local device
     * then no such guarantee is made.
     *
     * <p> The <tt>"rwd"</tt> mode can be used to reduce the number of I/O
     * operations performed.  Using <tt>"rwd"</tt> only requires updates to the
     * file's content to be written to storage; using <tt>"rws"</tt> requires
     * updates to both the file's content and its metadata to be written, which
     * generally requires at least one more low-level I/O operation.
     *
     * <p> If there is a security manager, its <code>checkRead</code> method is
     * called with the pathname of the <code>file</code> argument as its
     * argument to see if read access to the file is allowed.  If the mode
     * allows writing, the security manager's <code>checkWrite</code> method is
     * also called with the path argument to see if write access to the file is
     * allowed.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Creates a random access file stream to read from, and optionally to
     * write to, the file specified by the {@link File} argument.  A new {@link
     * FileDescriptor} object is created to represent this file connection.
     *
     * <a name="mode"><p> The <tt>mode</tt> argument specifies the access mode
     * in which the file is to be opened.  The permitted values and their
     * meanings are:
     *
     * <blockquote><table summary="Access mode permitted values and meanings">
...
tten, which
     * generally requires at least one more low-level I/O operation.
     *
     * <p> If there is a security manager, its <code>checkRead</code> method is
     * called with the pathname of the <code>file</code> argument as its
     * argument to see if read access to the file is allowed.  If the mode
     * allows writing, the security manager's <code>checkWrite</code> method is
     * also called with the path argument to see if write access to the file is
     * allowed.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public final boolean readBoolean() throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads a <code>boolean</code> from this file. This method reads a
     * single byte from the file, starting at the current file pointer.
     * A value of <code>0</code> represents
     * <code>false</code>. Any other value represents <code>true</code>.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads a <code>boolean</code> from this file. This method reads a
     * single byte from the file, starting at the current file pointer.
     * A value of <code>0</code> represents
     * <code>false</code>. Any other value represents <code>true</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     * {@description.close}
ADDRESSED DESC::: []
---------
NEAREST SIGNATURE::: 
    public int read(byte b[]) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Reads up to <code>b.length</code> bytes of data from this file
     * into an array of bytes.
     * {@description.close}
     * {@description.open blocking}
     * This method blocks until at least one byte
     * of input is available.
     * {@description.close}
     * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[])} method of
     * <code>InputStream</code>.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Reads up to <code>b.length</code> bytes of data from this file
     * into an array of bytes.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method blocks until at least one byte
     * of input is available.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open}
     * <p>
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
     * same way as the {@link InputStream#read(byte[])} method of
     * <code>InputStream</code>.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: PushbackReader.java
DIRECTORY: java/io
NEAREST SIGNATURE::: 
    public long skip(long n) throws IOException 
ORIG COMMENT::: /** {@collect.stats}
     * {@description.open}
     * Skips characters.
     * {@description.close}
     * {@description.open blocking}
     * This method will block until some characters are
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
     *
     
~
DESC BLOCK::: * {@description.open}
     * Skips characters.
     * {@description.close}
ADDRESSED DESC::: []
---------
DESC BLOCK::: * {@description.open blocking}
     * This method will block until some characters are
     * available, an I/O error occurs, or the end of the stream is reached.
     * {@description.close}
ADDRESSED DESC::: []
---------
FILE: InterruptedIOException.java
DIRECTORY: java/io
